// node_modules/gophergfx/src/math/Color.ts
var _Color = class {
  static copy(color) {
    const newColor = new _Color();
    newColor.r = color.r;
    newColor.g = color.g;
    newColor.b = color.b;
    newColor.a = color.a;
    return newColor;
  }
  static createFromString(color) {
    return new _Color(
      parseInt(color.substring(1, 3), 16) / 255,
      parseInt(color.substring(3, 5), 16) / 255,
      parseInt(color.substring(5, 7), 16) / 255
    );
  }
  static lerp(c1, c2, alpha) {
    return new _Color(
      c1.r * (1 - alpha) + c2.r * alpha,
      c1.g * (1 - alpha) + c2.g * alpha,
      c1.b * (1 - alpha) + c2.b * alpha,
      c1.a * (1 - alpha) + c2.a * alpha
    );
  }
  static add(c1, c2) {
    return new _Color(c1.r + c2.r, c1.g + c2.g, c1.b + c2.b);
  }
  static subtract(c1, c2) {
    return new _Color(c1.r - c2.r, c1.g - c2.g, c1.b - c2.b);
  }
  static multiply(c1, c2) {
    return new _Color(c1.r * c2.r, c1.g * c2.g, c1.b * c2.b);
  }
  static divide(c1, c2) {
    return new _Color(c1.r / c2.r, c1.g / c2.g, c1.b / c2.b);
  }
  static multiplyScalar(v, n) {
    return new _Color(v.r * n, v.g * n, v.b * n);
  }
  static divideScalar(v, n) {
    return new _Color(v.r / n, v.g / n, v.b / n);
  }
  constructor(r = 0, g = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  set(r = 0, g = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  setFromString(color) {
    this.r = parseInt(color.substring(1, 3), 16) / 255;
    this.g = parseInt(color.substring(3, 5), 16) / 255;
    this.b = parseInt(color.substring(5, 7), 16) / 255;
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    this.a = color.a;
  }
  clone() {
    return new _Color(this.r, this.g, this.b, this.a);
  }
  lerp(c1, c2, alpha) {
    this.r = c1.r * (1 - alpha) + c2.r * alpha;
    this.g = c1.g * (1 - alpha) + c2.g * alpha;
    this.b = c1.b * (1 - alpha) + c2.b * alpha;
    this.a = c1.b * (1 - alpha) + c2.a * alpha;
  }
  add(c) {
    this.r += c.r;
    this.g += c.g;
    this.b += c.b;
  }
  subtract(c) {
    this.r -= c.r;
    this.g -= c.g;
    this.b -= c.b;
  }
  multiply(c) {
    this.r *= c.r;
    this.g *= c.g;
    this.b *= c.b;
  }
  divide(c) {
    this.r /= c.r;
    this.g /= c.g;
    this.b /= c.b;
  }
  multiplyScalar(n) {
    this.r *= n;
    this.g *= n;
    this.b *= n;
  }
  divideScalar(n) {
    this.r /= n;
    this.g /= n;
    this.b /= n;
  }
};
var Color = _Color;
Color.WHITE = new _Color(1, 1, 1);
Color.BLACK = new _Color(0, 0, 0);
Color.RED = new _Color(1, 0, 0);
Color.GREEN = new _Color(0, 1, 0);
Color.BLUE = new _Color(0, 0, 1);
Color.YELLOW = new _Color(1, 1, 0);
Color.PURPLE = new _Color(1, 0, 1);
Color.CYAN = new _Color(0, 1, 1);

// node_modules/gophergfx/src/math/Vector2.ts
var _Vector2 = class {
  static copy(v) {
    return new _Vector2(v.x, v.y);
  }
  static inverse(v) {
    return new _Vector2(-v.x, -v.y);
  }
  static add(v1, v2) {
    return new _Vector2(v1.x + v2.x, v1.y + v2.y);
  }
  static subtract(v1, v2) {
    return new _Vector2(v1.x - v2.x, v1.y - v2.y);
  }
  static multiply(v1, v2) {
    return new _Vector2(v1.x * v2.x, v1.y * v2.y);
  }
  static divide(v1, v2) {
    return new _Vector2(v1.x / v2.x, v1.y / v2.y);
  }
  static multiplyScalar(v, n) {
    return new _Vector2(v.x * n, v.y * n);
  }
  static divideScalar(v, n) {
    return new _Vector2(v.x / n, v.y / n);
  }
  static distanceBetween(v1, v2) {
    return v1.distanceTo(v2);
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static angleBetweenSigned(v1, v2) {
    return v1.angleBetweenSigned(v2);
  }
  static dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
  }
  static normalize(v) {
    const sizeSquared = v.x * v.x + v.y * v.y;
    if (sizeSquared < 1e-8)
      return new _Vector2();
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    return new _Vector2(v.x * scaleFactor, v.y * scaleFactor);
  }
  static rotate(v, angle) {
    return new _Vector2(Math.cos(angle) * v.x - Math.sin(angle) * v.y, Math.sin(angle) * v.x + Math.cos(angle) * v.y);
  }
  static transform(v, m) {
    const result = new _Vector2(v.x, v.y);
    result.transform(m);
    return result;
  }
  static transformVector(v, m) {
    const result = new _Vector2(v.x, v.y);
    result.transformVector(m);
    return result;
  }
  static lerp(v1, v2, alpha) {
    return new _Vector2(
      v1.x * (1 - alpha) + v2.x * alpha,
      v1.y * (1 - alpha) + v2.y * alpha
    );
  }
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
  }
  clone() {
    return new _Vector2(this.x, this.y);
  }
  equals(v) {
    return this.x == v.x && this.y == v.y;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
  }
  subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
  }
  multiplyScalar(n) {
    this.x *= n;
    this.y *= n;
  }
  divideScalar(n) {
    this.x /= n;
    this.y /= n;
  }
  distanceTo(v) {
    return Math.sqrt(
      (this.x - v.x) * (this.x - v.x) + (this.y - v.y) * (this.y - v.y)
    );
  }
  setPositionFromMatrix(m) {
    this.x = m.mat[6];
    this.y = m.mat[7];
  }
  setScaleFromMatrix(m) {
    this.x = Math.sqrt(m.mat[0] * m.mat[0] + m.mat[1] * m.mat[1]);
    this.y = Math.sqrt(m.mat[3] * m.mat[3] + m.mat[4] * m.mat[4]);
  }
  transform(m) {
    const v = this.clone();
    const w = 1 / (m.mat[2] * v.x + m.mat[5] * v.y + m.mat[8]);
    this.x = w * (m.mat[0] * v.x + m.mat[3] * v.y + m.mat[6]);
    this.y = w * (m.mat[1] * v.x + m.mat[4] * v.y + m.mat[7]);
  }
  transformVector(m) {
    const v = this.clone();
    const w = 1 / (m.mat[2] * v.x + m.mat[5] * v.y);
    this.x = w * (m.mat[0] * v.x + m.mat[3] * v.y);
    this.y = w * (m.mat[1] * v.x + m.mat[4] * v.y);
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  normalize() {
    const sizeSquared = this.x * this.x + this.y * this.y;
    if (sizeSquared < 1e-8)
      return;
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    this.x *= scaleFactor;
    this.y *= scaleFactor;
  }
  invert() {
    this.x = -this.x;
    this.y = -this.y;
  }
  angleBetween(v) {
    const v1Norm = _Vector2.normalize(this);
    const v2Norm = _Vector2.normalize(v);
    return Math.acos(v1Norm.dot(v2Norm));
  }
  angleBetweenSigned(v) {
    const v1Norm = _Vector2.normalize(this);
    const v2Norm = _Vector2.normalize(v);
    return Math.atan2(v2Norm.y, v2Norm.x) - Math.atan2(v1Norm.y, v1Norm.x);
  }
  rotate(angle) {
    const x = this.x;
    const y = this.y;
    this.x = Math.cos(angle) * x - Math.sin(angle) * y;
    this.y = Math.sin(angle) * x + Math.cos(angle) * y;
  }
  lerp(v1, v2, alpha) {
    this.x = v1.x * (1 - alpha) + v2.x * alpha;
    this.y = v1.y * (1 - alpha) + v2.y * alpha;
  }
};
var Vector2 = _Vector2;
Vector2.ZERO = new _Vector2(0, 0);
Vector2.ONE = new _Vector2(1, 1);
Vector2.UP = new _Vector2(0, 1);
Vector2.DOWN = new _Vector2(0, -1);
Vector2.LEFT = new _Vector2(-1, 0);
Vector2.RIGHT = new _Vector2(1, 0);
Vector2.X_AXIS = _Vector2.RIGHT;
Vector2.Y_AXIS = _Vector2.UP;

// node_modules/gophergfx/src/math/MathUtils.ts
var MathUtils = class {
  static degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  static radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  }
  static rescale(value, min, max, scaledMin, scaledMax) {
    return scaledMin + (scaledMax - scaledMin) * (value - min) / (max - min);
  }
  static clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  static lerp(x, y, alpha) {
    return x * (1 - alpha) + y * alpha;
  }
};

// node_modules/gophergfx/src/core/Renderer.ts
var Viewport = /* @__PURE__ */ ((Viewport2) => {
  Viewport2[Viewport2["FIT"] = 0] = "FIT";
  Viewport2[Viewport2["CROP"] = 1] = "CROP";
  Viewport2[Viewport2["STRETCH"] = 2] = "STRETCH";
  return Viewport2;
})(Viewport || {});
var Renderer = class {
  constructor(enableStencilBuffer = false) {
    this.gfxCanvas = document.getElementById("gfxCanvas");
    if (!this.gfxCanvas) {
      alert("Unable to find gfxCanvas.");
    }
    this.gfxCanvas.width = window.innerWidth;
    this.gfxCanvas.height = window.innerHeight;
    const gl = this.gfxCanvas.getContext("webgl2", { alpha: false, stencil: enableStencilBuffer });
    if (!gl) {
      alert("Unable to initialize WebGL. Your browser or machine may not support it.");
    }
    this.gl = gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.enable(this.gl.BLEND);
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    this.background = new Color();
    this.viewport = 0 /* FIT */;
  }
  resize(width, height, aspectRatio) {
    this.gfxCanvas.width = width;
    this.gfxCanvas.height = height;
    if (this.viewport == 0 /* FIT */) {
      if (aspectRatio > window.innerWidth / window.innerHeight) {
        this.gl.viewport(
          0,
          (window.innerHeight - window.innerWidth / aspectRatio) / 2,
          window.innerWidth,
          window.innerWidth / aspectRatio
        );
      } else {
        this.gl.viewport(
          (window.innerWidth - window.innerHeight * aspectRatio) / 2,
          0,
          window.innerHeight * aspectRatio,
          window.innerHeight
        );
      }
    } else if (this.viewport == 1 /* CROP */) {
      if (aspectRatio > window.innerWidth / window.innerHeight) {
        this.gl.viewport(
          (window.innerWidth - window.innerHeight * aspectRatio) / 2,
          0,
          window.innerHeight * aspectRatio,
          window.innerHeight
        );
      } else {
        this.gl.viewport(
          0,
          (window.innerHeight - window.innerWidth / aspectRatio) / 2,
          window.innerWidth,
          window.innerWidth / aspectRatio
        );
      }
    } else {
      this.gl.viewport(
        0,
        0,
        window.innerWidth,
        window.innerHeight
      );
    }
  }
  render(scene, camera) {
    if (camera.projectionMatrixDirty) {
      this.resize(this.gfxCanvas.width, this.gfxCanvas.height, camera.getAspectRatio());
      camera.projectionMatrixDirty = false;
    }
    this.gl.clearColor(this.background.r, this.background.g, this.background.b, this.background.a);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    scene.draw(camera);
  }
  getNormalizedDeviceCoordinates(mouseX, mouseY) {
    const viewport = this.gl.getParameter(this.gl.VIEWPORT);
    return new Vector2(
      MathUtils.clamp((mouseX - viewport[0]) / viewport[2] * 2 - 1, -1, 1),
      MathUtils.clamp((mouseY - viewport[1]) / viewport[3] * -2 + 1, -1, 1)
    );
  }
};

// node_modules/gophergfx/src/math/Vector3.ts
var _Vector3 = class {
  static copy(v) {
    return new _Vector3(v.x, v.y, v.z);
  }
  static inverse(v) {
    return new _Vector3(-v.x, -v.y, -v.z);
  }
  static add(v1, v2) {
    return new _Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
  }
  static subtract(v1, v2) {
    return new _Vector3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
  }
  static multiply(v1, v2) {
    return new _Vector3(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
  }
  static divide(v1, v2) {
    return new _Vector3(v1.x / v2.x, v1.y / v2.y, v1.z / v2.z);
  }
  static dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  }
  static cross(v1, v2) {
    return new _Vector3(
      v1.y * v2.z - v1.z * v2.y,
      v1.z * v2.x - v1.x * v2.z,
      v1.x * v2.y - v1.y * v2.x
    );
  }
  static multiplyScalar(v, n) {
    return new _Vector3(v.x * n, v.y * n, v.z * n);
  }
  static divideScalar(v, n) {
    return new _Vector3(v.x / n, v.y / n, v.z / n);
  }
  static normalize(v) {
    const sizeSquared = v.x * v.x + v.y * v.y + v.z * v.z;
    if (sizeSquared < 1e-8)
      return new _Vector3();
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    return new _Vector3(v.x * scaleFactor, v.y * scaleFactor, v.z * scaleFactor);
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static distanceBetween(v1, v2) {
    return v1.distanceTo(v2);
  }
  static rotate(v, q) {
    const u = new _Vector3(q.x, q.y, q.z);
    const result = _Vector3.multiplyScalar(u, 2 * u.dot(v));
    result.add(_Vector3.multiplyScalar(v, q.w * q.w - u.dot(u)));
    const crossUV = _Vector3.cross(u, v);
    crossUV.multiplyScalar(2 * q.w);
    result.add(crossUV);
    return result;
  }
  static lerp(v1, v2, alpha) {
    return new _Vector3(
      v1.x * (1 - alpha) + v2.x * alpha,
      v1.y * (1 - alpha) + v2.y * alpha,
      v1.z * (1 - alpha) + v2.z * alpha
    );
  }
  static transform(v, m) {
    const result = new _Vector3(v.x, v.y, v.z);
    result.transform(m);
    return result;
  }
  static transformVector(v, m) {
    const result = new _Vector3(v.x, v.y, v.z);
    result.transformVector(m);
    return result;
  }
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  }
  clone() {
    return new _Vector3(this.x, this.y, this.z);
  }
  equals(v) {
    return this.x == v.x && this.y == v.y && this.z == v.z;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
  }
  subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(v) {
    const crossProduct = new _Vector3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
    this.copy(crossProduct);
  }
  multiplyScalar(n) {
    this.x *= n;
    this.y *= n;
    this.z *= n;
  }
  divideScalar(n) {
    this.x /= n;
    this.y /= n;
    this.z /= n;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  normalize() {
    const sizeSquared = this.x * this.x + this.y * this.y + this.z * this.z;
    if (sizeSquared < 1e-8)
      return;
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    this.x *= scaleFactor;
    this.y *= scaleFactor;
    this.z *= scaleFactor;
  }
  invert() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
  }
  transform(m) {
    const v = this.clone();
    const w = 1 / (m.mat[3] * v.x + m.mat[7] * v.y + m.mat[11] * v.z + m.mat[15]);
    this.x = w * (m.mat[0] * v.x + m.mat[4] * v.y + m.mat[8] * v.z + m.mat[12]);
    this.y = w * (m.mat[1] * v.x + m.mat[5] * v.y + m.mat[9] * v.z + m.mat[13]);
    this.z = w * (m.mat[2] * v.x + m.mat[6] * v.y + m.mat[10] * v.z + m.mat[14]);
  }
  transformVector(m) {
    const v = this.clone();
    const w = 1 / (m.mat[3] * v.x + m.mat[7] * v.y + m.mat[11] * v.z);
    this.x = w * (m.mat[0] * v.x + m.mat[4] * v.y + m.mat[8] * v.z);
    this.y = w * (m.mat[1] * v.x + m.mat[5] * v.y + m.mat[9] * v.z);
    this.z = w * (m.mat[2] * v.x + m.mat[6] * v.y + m.mat[10] * v.z);
  }
  rotate(q) {
    this.copy(_Vector3.rotate(this, q));
  }
  angleBetween(v) {
    const v1Norm = _Vector3.normalize(this);
    const v2Norm = _Vector3.normalize(v);
    return Math.acos(v1Norm.dot(v2Norm));
  }
  distanceTo(v) {
    return Math.sqrt(
      (this.x - v.x) * (this.x - v.x) + (this.y - v.y) * (this.y - v.y) + (this.z - v.z) * (this.z - v.z)
    );
  }
  setPositionFromMatrix(m) {
    this.x = m.mat[12];
    this.y = m.mat[13];
    this.z = m.mat[14];
  }
  setScaleFromMatrix(m) {
    this.x = Math.sqrt(m.mat[0] * m.mat[0] + m.mat[1] * m.mat[1] + m.mat[2] * m.mat[2]);
    this.y = Math.sqrt(m.mat[4] * m.mat[4] + m.mat[5] * m.mat[5] + m.mat[6] * m.mat[6]);
    this.z = Math.sqrt(m.mat[8] * m.mat[8] + m.mat[9] * m.mat[9] + m.mat[10] * m.mat[10]);
  }
  lerp(v1, v2, alpha) {
    this.x = v1.x * (1 - alpha) + v2.x * alpha;
    this.y = v1.y * (1 - alpha) + v2.y * alpha;
    this.z = v1.z * (1 - alpha) + v2.z * alpha;
  }
};
var Vector3 = _Vector3;
Vector3.ZERO = new _Vector3(0, 0, 0);
Vector3.ONE = new _Vector3(1, 1, 1);
Vector3.UP = new _Vector3(0, 1, 0);
Vector3.DOWN = new _Vector3(0, -1, 0);
Vector3.LEFT = new _Vector3(-1, 0, 0);
Vector3.RIGHT = new _Vector3(1, 0, 0);
Vector3.FORWARD = new _Vector3(0, 0, -1);
Vector3.BACK = new _Vector3(0, 0, 1);
Vector3.X_AXIS = _Vector3.RIGHT;
Vector3.Y_AXIS = _Vector3.UP;
Vector3.Z_AXIS = _Vector3.FORWARD;

// node_modules/gophergfx/src/math/Quaternion.ts
var _Quaternion = class {
  static copy(q) {
    return new _Quaternion(q.x, q.y, q.z, q.w);
  }
  static multiply(q1, q2) {
    const dest = new _Quaternion();
    dest.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
    dest.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
    dest.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
    dest.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;
    return dest;
  }
  static premultiply(q1, q2) {
    const dest = new _Quaternion();
    dest.w = q2.w * q1.w - q2.x * q1.x - q2.y * q1.y - q2.z * q1.z;
    dest.x = q2.w * q1.x + q2.x * q1.w + q2.y * q1.z - q2.z * q1.y;
    dest.y = q2.w * q1.y + q2.y * q1.w + q2.z * q1.x - q2.x * q1.z;
    dest.z = q2.w * q1.z + q2.z * q1.w + q2.x * q1.y - q2.y * q1.x;
    return dest;
  }
  static normalize(q) {
    const dest = q.clone();
    dest.normalize();
    return dest;
  }
  static inverse(q) {
    const dest = q.clone();
    dest.invert();
    return dest;
  }
  makeIdentity() {
    return new _Quaternion(0, 0, 0, 1);
  }
  static makeRotationX(angle) {
    const dest = new _Quaternion();
    dest.setRotationX(angle);
    return dest;
  }
  static makeRotationY(angle) {
    const dest = new _Quaternion();
    dest.setRotationY(angle);
    return dest;
  }
  static makeRotationZ(angle) {
    const dest = new _Quaternion();
    dest.setRotationZ(angle);
    return dest;
  }
  static makeAxisAngle(axis, angle) {
    const dest = new _Quaternion();
    dest.setAxisAngle(axis, angle);
    return dest;
  }
  static makeEulerAngles(x, y, z, order = "YZX") {
    const dest = new _Quaternion();
    dest.setEulerAngles(x, y, z, order);
    return dest;
  }
  static makeMatrix(matrix) {
    const dest = new _Quaternion();
    dest.setMatrix(matrix);
    return dest;
  }
  static slerp(q1, q2, alpha) {
    const q = new _Quaternion();
    q.slerp(q1, q2, alpha);
    return q;
  }
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  setIdentity() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 1;
  }
  setRotationX(angle) {
    this.w = Math.cos(angle / 2);
    this.x = Math.sin(angle / 2);
    this.y = 0;
    this.z = 0;
  }
  setRotationY(angle) {
    this.w = Math.cos(angle / 2);
    this.x = 0;
    this.y = Math.sin(angle / 2);
    this.z = 0;
  }
  setRotationZ(angle) {
    this.w = Math.cos(angle / 2);
    this.x = 0;
    this.y = 0;
    this.z = Math.sin(angle / 2);
  }
  setAxisAngle(axis, angle) {
    const sinAngle = Math.sin(angle / 2);
    this.w = Math.cos(angle / 2);
    this.x = sinAngle * axis.x;
    this.y = sinAngle * axis.y;
    this.z = sinAngle * axis.z;
  }
  setEulerAngles(x, y, z, order = "YZX") {
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
    }
  }
  setMatrix(matrix) {
    const trace = matrix.mat[0] + matrix.mat[5] + matrix.mat[10];
    if (trace > 0) {
      const s = Math.sqrt(trace + 1) * 2;
      this.w = 0.25 * s;
      this.x = (matrix.mat[6] - matrix.mat[9]) / s;
      this.y = (matrix.mat[8] - matrix.mat[2]) / s;
      this.z = (matrix.mat[1] - matrix.mat[4]) / s;
    } else if (matrix.mat[0] > matrix.mat[5] && matrix.mat[0] > matrix.mat[10]) {
      const s = Math.sqrt(1 + matrix.mat[0] - matrix.mat[5] - matrix.mat[10]) * 2;
      this.w = (matrix.mat[6] - matrix.mat[9]) / s;
      this.x = 0.25 * s;
      this.y = (matrix.mat[4] + matrix.mat[1]) / s;
      this.z = (matrix.mat[8] + matrix.mat[2]) / s;
    } else if (matrix.mat[5] > matrix.mat[10]) {
      const s = Math.sqrt(1 + matrix.mat[5] - matrix.mat[0] - matrix.mat[10]) * 2;
      this.w = (matrix.mat[8] - matrix.mat[2]) / s;
      this.x = (matrix.mat[4] + matrix.mat[1]) / s;
      this.y = 0.25 * s;
      this.z = (matrix.mat[9] + matrix.mat[6]) / s;
    } else {
      const s = Math.sqrt(1 + matrix.mat[10] - matrix.mat[0] - matrix.mat[5]) * 2;
      this.w = (matrix.mat[1] - matrix.mat[4]) / s;
      this.x = (matrix.mat[8] + matrix.mat[2]) / s;
      this.y = (matrix.mat[9] + matrix.mat[6]) / s;
      this.z = 0.25 * s;
    }
  }
  copy(q) {
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    this.w = q.w;
  }
  clone() {
    return new _Quaternion(this.x, this.y, this.z, this.w);
  }
  multiply(q) {
    this.copy(_Quaternion.multiply(this, q));
  }
  premultiply(q) {
    this.copy(_Quaternion.multiply(q, this));
  }
  normalize() {
    const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= normalizeFactor;
    this.y *= normalizeFactor;
    this.z *= normalizeFactor;
    this.w *= normalizeFactor;
  }
  invert() {
    const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= -normalizeFactor;
    this.y *= -normalizeFactor;
    this.z *= -normalizeFactor;
    this.w *= normalizeFactor;
  }
  inverse() {
    return _Quaternion.inverse(this);
  }
  getMatrix() {
    const sqw = this.w * this.w;
    const sqx = this.x * this.x;
    const sqy = this.y * this.y;
    const sqz = this.z * this.z;
    const invs = 1 / (sqx + sqy + sqz + sqw);
    const tmp1 = this.x * this.y;
    const tmp2 = this.z * this.w;
    const tmp3 = this.x * this.z;
    const tmp4 = this.y * this.w;
    const tmp5 = this.y * this.z;
    const tmp6 = this.x * this.w;
    return Matrix4.fromRowMajor(
      (sqx - sqy - sqz + sqw) * invs,
      2 * (tmp1 - tmp2) * invs,
      2 * (tmp3 + tmp4) * invs,
      0,
      2 * (tmp1 + tmp2) * invs,
      (-sqx + sqy - sqz + sqw) * invs,
      2 * (tmp5 - tmp6) * invs,
      0,
      2 * (tmp3 - tmp4) * invs,
      2 * (tmp5 + tmp6) * invs,
      -sqx - sqy + sqz + sqw,
      0,
      0,
      0,
      0,
      1
    );
  }
  lookAt(eye, target, up = Vector3.UP) {
    const z = Vector3.subtract(eye, target);
    z.normalize();
    const x = Vector3.cross(up, z);
    x.normalize();
    const y = Vector3.cross(z, x);
    y.normalize();
    const m = new Matrix4();
    m.setRowMajor(
      x.x,
      y.x,
      z.x,
      0,
      x.y,
      y.y,
      z.y,
      0,
      x.z,
      y.z,
      z.z,
      0,
      0,
      0,
      0,
      1
    );
    this.setMatrix(m);
  }
  slerp(q1, q2, alpha) {
    const temp = q1.clone();
    let cosOmega = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
    let omega, sinOmega, startScale, endScale;
    if (cosOmega < 0) {
      cosOmega *= -1;
      temp.x *= -1;
      temp.y *= -1;
      temp.z *= -1;
      temp.w *= -1;
    }
    if (1 + cosOmega > 1e-5) {
      if (1 - cosOmega > 1e-5) {
        omega = Math.acos(cosOmega);
        sinOmega = Math.sin(omega);
        startScale = Math.sin((1 - alpha) * omega) / sinOmega;
        endScale = Math.sin(alpha * omega) / sinOmega;
      } else {
        startScale = 1 - alpha;
        endScale = alpha;
      }
      this.x = startScale * temp.x + endScale * q2.x;
      this.y = startScale * temp.y + endScale * q2.y;
      this.z = startScale * temp.z + endScale * q2.z;
      this.w = startScale * temp.w + endScale * q2.w;
    } else {
      this.x = -temp.y;
      this.y = temp.x;
      this.z = -temp.w;
      this.w = temp.z;
      startScale = Math.sin((0.5 - alpha) * Math.PI);
      endScale = Math.sin(alpha * Math.PI);
      this.x = startScale * temp.x + endScale * this.x;
      this.y = startScale * temp.y + endScale * this.y;
      this.z = startScale * temp.y + endScale * this.z;
    }
  }
};
var Quaternion = _Quaternion;
Quaternion.IDENTITY = new _Quaternion();

// node_modules/gophergfx/src/math/Matrix4.ts
var _Matrix4 = class {
  static multiply(m1, m2) {
    const m = new _Matrix4();
    m.mat[0] = 0;
    m.mat[5] = 0;
    m.mat[10] = 0;
    m.mat[15] = 0;
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        for (let i = 0; i < 4; i++) {
          m.mat[r * 4 + c] += m1.mat[r * 4 + i] * m2.mat[i * 4 + c];
        }
      }
    }
    return m;
  }
  static copy(m) {
    const mat = new _Matrix4();
    mat.copy(m);
    return mat;
  }
  static fromRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    const matrix = new _Matrix4();
    matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);
    return matrix;
  }
  static fromColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    const matrix = new _Matrix4();
    matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);
    return matrix;
  }
  static makeIdentity() {
    return _Matrix4.fromRowMajor(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  static makeTranslation(v) {
    return _Matrix4.fromRowMajor(
      1,
      0,
      0,
      v.x,
      0,
      1,
      0,
      v.y,
      0,
      0,
      1,
      v.z,
      0,
      0,
      0,
      1
    );
  }
  static makeRotation(rotation) {
    const matrix = new _Matrix4();
    matrix.setRotation(rotation);
    return matrix;
  }
  static makeRotationX(angle) {
    const matrix = new _Matrix4();
    matrix.setRotationX(angle);
    return matrix;
  }
  static makeRotationY(angle) {
    const matrix = new _Matrix4();
    matrix.setRotationY(angle);
    return matrix;
  }
  static makeRotationZ(angle) {
    const matrix = new _Matrix4();
    matrix.setRotationZ(angle);
    return matrix;
  }
  static makeAxisAngle(axis, angle) {
    const matrix = new _Matrix4();
    matrix.setAxisAngle(axis, angle);
    return matrix;
  }
  static makeEulerAngles(x, y, z, order = "YZX") {
    const dest = new _Matrix4();
    dest.setEulerAngles(x, y, z, order);
    return dest;
  }
  static makeScale(scale) {
    const matrix = new _Matrix4();
    matrix.setScale(scale);
    return matrix;
  }
  static compose(position = Vector3.ZERO, rotation = Quaternion.IDENTITY, scale = Vector3.UP) {
    const matrix = new _Matrix4();
    matrix.compose(position, rotation, scale);
    return matrix;
  }
  static lookAt(eye, target, up) {
    const matrix = new _Matrix4();
    matrix.lookAt(eye, target, up);
    return matrix;
  }
  static makeOrthographic(left, right, bottom, top, near, far) {
    const matrix = new _Matrix4();
    matrix.setOrthographic(left, right, bottom, top, near, far);
    return matrix;
  }
  static makePerspective(fov, aspectRatio, near, far) {
    const matrix = new _Matrix4();
    matrix.setPerspective(fov, aspectRatio, near, far);
    return matrix;
  }
  static makeFrustum(left, right, bottom, top, near, far) {
    const matrix = new _Matrix4();
    matrix.setFrustum(left, right, bottom, top, near, far);
    return matrix;
  }
  constructor() {
    this.mat = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    this.mat[0] = n1;
    this.mat[1] = n2;
    this.mat[2] = n3;
    this.mat[3] = n4;
    this.mat[4] = n5;
    this.mat[5] = n6;
    this.mat[6] = n7;
    this.mat[7] = n8;
    this.mat[8] = n9;
    this.mat[9] = n10;
    this.mat[10] = n11;
    this.mat[11] = n12;
    this.mat[12] = n13;
    this.mat[13] = n14;
    this.mat[14] = n15;
    this.mat[15] = n16;
  }
  setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    this.mat[0] = n1;
    this.mat[1] = n5;
    this.mat[2] = n9;
    this.mat[3] = n13;
    this.mat[4] = n2;
    this.mat[5] = n6;
    this.mat[6] = n10;
    this.mat[7] = n14;
    this.mat[8] = n3;
    this.mat[9] = n7;
    this.mat[10] = n11;
    this.mat[11] = n15;
    this.mat[12] = n4;
    this.mat[13] = n8;
    this.mat[14] = n12;
    this.mat[15] = n16;
  }
  copy(m) {
    for (let i = 0; i < 16; i++)
      this.mat[i] = m.mat[i];
  }
  clone() {
    const matrix = new _Matrix4();
    for (let i = 0; i < 16; i++)
      matrix.mat[i] = this.mat[i];
    return matrix;
  }
  element(row, col) {
    return this.mat[col * 4 + row];
  }
  set(value, row, col) {
    this.mat[col * 4 + row] = value;
  }
  multiply(m) {
    const temp = _Matrix4.multiply(m, this);
    this.copy(temp);
  }
  premultiply(m) {
    const temp = _Matrix4.multiply(this, m);
    this.copy(temp);
  }
  setIdentity() {
    this.setRowMajor(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  setTranslation(v) {
    this.setRowMajor(
      1,
      0,
      0,
      v.x,
      0,
      1,
      0,
      v.y,
      0,
      0,
      1,
      v.z,
      0,
      0,
      0,
      1
    );
  }
  setRotation(rotation) {
    const sqw = rotation.w * rotation.w;
    const sqx = rotation.x * rotation.x;
    const sqy = rotation.y * rotation.y;
    const sqz = rotation.z * rotation.z;
    const invs = 1 / (sqx + sqy + sqz + sqw);
    const tmp1 = rotation.x * rotation.y;
    const tmp2 = rotation.z * rotation.w;
    const tmp3 = rotation.x * rotation.z;
    const tmp4 = rotation.y * rotation.w;
    const tmp5 = rotation.y * rotation.z;
    const tmp6 = rotation.x * rotation.w;
    this.setRowMajor(
      (sqx - sqy - sqz + sqw) * invs,
      2 * (tmp1 - tmp2) * invs,
      2 * (tmp3 + tmp4) * invs,
      0,
      2 * (tmp1 + tmp2) * invs,
      (-sqx + sqy - sqz + sqw) * invs,
      2 * (tmp5 - tmp6) * invs,
      0,
      2 * (tmp3 - tmp4) * invs,
      2 * (tmp5 + tmp6) * invs,
      -sqx - sqy + sqz + sqw,
      0,
      0,
      0,
      0,
      1
    );
  }
  setRotationX(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      1,
      0,
      0,
      0,
      0,
      cosTheta,
      -sinTheta,
      0,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      0,
      1
    );
  }
  setRotationY(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      0,
      sinTheta,
      0,
      0,
      1,
      0,
      0,
      -sinTheta,
      0,
      cosTheta,
      0,
      0,
      0,
      0,
      1
    );
  }
  setRotationZ(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      -sinTheta,
      0,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  setAxisAngle(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.setRowMajor(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
  }
  setScale(scale) {
    this.setRowMajor(
      scale.x,
      0,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      0,
      scale.z,
      0,
      0,
      0,
      0,
      1
    );
  }
  getTranslation() {
    return new Vector3(this.mat[12], this.mat[13], this.mat[14]);
  }
  getRotation() {
    return Quaternion.makeMatrix(this);
  }
  getScale() {
    return new Vector3(
      Math.sqrt(this.mat[0] * this.mat[0] + this.mat[1] * this.mat[1] + this.mat[2] * this.mat[2]),
      Math.sqrt(this.mat[4] * this.mat[4] + this.mat[5] * this.mat[5] + this.mat[6] * this.mat[6]),
      Math.sqrt(this.mat[8] * this.mat[8] + this.mat[9] * this.mat[9] + this.mat[10] * this.mat[10])
    );
  }
  setOrthographic(left, right, bottom, top, near, far) {
    this.setRowMajor(
      2 / (right - left),
      0,
      0,
      -(right + left) / (right - left),
      0,
      2 / (top - bottom),
      0,
      -(top + bottom) / (top - bottom),
      0,
      0,
      -2 / (far - near),
      -(far + near) / (far - near),
      0,
      0,
      0,
      1
    );
  }
  setPerspective(fov, aspectRatio, near, far) {
    const yMax = near * Math.tan(fov * Math.PI / 360);
    const xMax = yMax * aspectRatio;
    this.setFrustum(-xMax, xMax, -yMax, yMax, near, far);
  }
  setFrustum(left, right, bottom, top, near, far) {
    this.setRowMajor(
      2 * near / (right - left),
      0,
      (right + left) / (right - left),
      0,
      0,
      2 * near / (top - bottom),
      (top + bottom) / (top - bottom),
      0,
      0,
      0,
      -(far + near) / (far - near),
      -2 * far * near / (far - near),
      0,
      0,
      -1,
      0
    );
  }
  lookAt(eye, target, up = Vector3.UP) {
    const z = Vector3.subtract(eye, target);
    z.normalize();
    const x = Vector3.cross(up, z);
    x.normalize();
    const y = Vector3.cross(z, x);
    y.normalize();
    const rotation = _Matrix4.fromRowMajor(
      x.x,
      y.x,
      z.x,
      0,
      x.y,
      y.y,
      z.y,
      0,
      x.z,
      y.z,
      z.z,
      0,
      0,
      0,
      0,
      1
    );
    const translation = _Matrix4.makeTranslation(eye);
    this.copy(_Matrix4.multiply(rotation, translation));
  }
  multiplyScalar(x) {
    for (let i = 0; i < 16; i++)
      this.mat[i] *= x;
  }
  determinant() {
    const determinant = this.mat[3] * this.mat[6] * this.mat[9] * this.mat[12] - this.mat[2] * this.mat[7] * this.mat[9] * this.mat[12] - this.mat[3] * this.mat[5] * this.mat[10] * this.mat[12] + this.mat[1] * this.mat[7] * this.mat[10] * this.mat[12] + this.mat[2] * this.mat[5] * this.mat[11] * this.mat[12] - this.mat[1] * this.mat[6] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[6] * this.mat[8] * this.mat[13] + this.mat[2] * this.mat[7] * this.mat[8] * this.mat[13] + this.mat[3] * this.mat[4] * this.mat[10] * this.mat[13] - this.mat[0] * this.mat[7] * this.mat[10] * this.mat[13] - this.mat[2] * this.mat[4] * this.mat[11] * this.mat[13] + this.mat[0] * this.mat[6] * this.mat[11] * this.mat[13] + this.mat[3] * this.mat[5] * this.mat[8] * this.mat[14] - this.mat[1] * this.mat[7] * this.mat[8] * this.mat[14] - this.mat[3] * this.mat[4] * this.mat[9] * this.mat[14] + this.mat[0] * this.mat[7] * this.mat[9] * this.mat[14] + this.mat[1] * this.mat[4] * this.mat[11] * this.mat[14] - this.mat[0] * this.mat[5] * this.mat[11] * this.mat[14] - this.mat[2] * this.mat[5] * this.mat[8] * this.mat[15] + this.mat[1] * this.mat[6] * this.mat[8] * this.mat[15] + this.mat[2] * this.mat[4] * this.mat[9] * this.mat[15] - this.mat[0] * this.mat[6] * this.mat[9] * this.mat[15] - this.mat[1] * this.mat[4] * this.mat[10] * this.mat[15] + this.mat[0] * this.mat[5] * this.mat[10] * this.mat[15];
    return determinant;
  }
  inverse() {
    const determinant = this.determinant();
    if (Math.abs(determinant) < 1e-8)
      return new _Matrix4();
    const inverse = new _Matrix4();
    inverse.mat[0] = (this.mat[6] * this.mat[11] * this.mat[13] - this.mat[7] * this.mat[10] * this.mat[13] + this.mat[7] * this.mat[9] * this.mat[14] - this.mat[5] * this.mat[11] * this.mat[14] - this.mat[6] * this.mat[9] * this.mat[15] + this.mat[5] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[1] = (this.mat[3] * this.mat[10] * this.mat[13] - this.mat[2] * this.mat[11] * this.mat[13] - this.mat[3] * this.mat[9] * this.mat[14] + this.mat[1] * this.mat[11] * this.mat[14] + this.mat[2] * this.mat[9] * this.mat[15] - this.mat[1] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[2] = (this.mat[2] * this.mat[7] * this.mat[13] - this.mat[3] * this.mat[6] * this.mat[13] + this.mat[3] * this.mat[5] * this.mat[14] - this.mat[1] * this.mat[7] * this.mat[14] - this.mat[2] * this.mat[5] * this.mat[15] + this.mat[1] * this.mat[6] * this.mat[15]) / determinant;
    inverse.mat[3] = (this.mat[3] * this.mat[6] * this.mat[9] - this.mat[2] * this.mat[7] * this.mat[9] - this.mat[3] * this.mat[5] * this.mat[10] + this.mat[1] * this.mat[7] * this.mat[10] + this.mat[2] * this.mat[5] * this.mat[11] - this.mat[1] * this.mat[6] * this.mat[11]) / determinant;
    inverse.mat[4] = (this.mat[7] * this.mat[10] * this.mat[12] - this.mat[6] * this.mat[11] * this.mat[12] - this.mat[7] * this.mat[8] * this.mat[14] + this.mat[4] * this.mat[11] * this.mat[14] + this.mat[6] * this.mat[8] * this.mat[15] - this.mat[4] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[5] = (this.mat[2] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[10] * this.mat[12] + this.mat[3] * this.mat[8] * this.mat[14] - this.mat[0] * this.mat[11] * this.mat[14] - this.mat[2] * this.mat[8] * this.mat[15] + this.mat[0] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[6] = (this.mat[3] * this.mat[6] * this.mat[12] - this.mat[2] * this.mat[7] * this.mat[12] - this.mat[3] * this.mat[4] * this.mat[14] + this.mat[0] * this.mat[7] * this.mat[14] + this.mat[2] * this.mat[4] * this.mat[15] - this.mat[0] * this.mat[6] * this.mat[15]) / determinant;
    inverse.mat[7] = (this.mat[2] * this.mat[7] * this.mat[8] - this.mat[3] * this.mat[6] * this.mat[8] + this.mat[3] * this.mat[4] * this.mat[10] - this.mat[0] * this.mat[7] * this.mat[10] - this.mat[2] * this.mat[4] * this.mat[11] + this.mat[0] * this.mat[6] * this.mat[11]) / determinant;
    inverse.mat[8] = (this.mat[5] * this.mat[11] * this.mat[12] - this.mat[7] * this.mat[9] * this.mat[12] + this.mat[7] * this.mat[8] * this.mat[13] - this.mat[4] * this.mat[11] * this.mat[13] - this.mat[5] * this.mat[8] * this.mat[15] + this.mat[4] * this.mat[9] * this.mat[15]) / determinant;
    inverse.mat[9] = (this.mat[3] * this.mat[9] * this.mat[12] - this.mat[1] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[8] * this.mat[13] + this.mat[0] * this.mat[11] * this.mat[13] + this.mat[1] * this.mat[8] * this.mat[15] - this.mat[0] * this.mat[9] * this.mat[15]) / determinant;
    inverse.mat[10] = (this.mat[1] * this.mat[7] * this.mat[12] - this.mat[3] * this.mat[5] * this.mat[12] + this.mat[3] * this.mat[4] * this.mat[13] - this.mat[0] * this.mat[7] * this.mat[13] - this.mat[1] * this.mat[4] * this.mat[15] + this.mat[0] * this.mat[5] * this.mat[15]) / determinant;
    inverse.mat[11] = (this.mat[3] * this.mat[5] * this.mat[8] - this.mat[1] * this.mat[7] * this.mat[8] - this.mat[3] * this.mat[4] * this.mat[9] + this.mat[0] * this.mat[7] * this.mat[9] + this.mat[1] * this.mat[4] * this.mat[11] - this.mat[0] * this.mat[5] * this.mat[11]) / determinant;
    inverse.mat[12] = (this.mat[6] * this.mat[9] * this.mat[12] - this.mat[5] * this.mat[10] * this.mat[12] - this.mat[6] * this.mat[8] * this.mat[13] + this.mat[4] * this.mat[10] * this.mat[13] + this.mat[5] * this.mat[8] * this.mat[14] - this.mat[4] * this.mat[9] * this.mat[14]) / determinant;
    inverse.mat[13] = (this.mat[1] * this.mat[10] * this.mat[12] - this.mat[2] * this.mat[9] * this.mat[12] + this.mat[2] * this.mat[8] * this.mat[13] - this.mat[0] * this.mat[10] * this.mat[13] - this.mat[1] * this.mat[8] * this.mat[14] + this.mat[0] * this.mat[9] * this.mat[14]) / determinant;
    inverse.mat[14] = (this.mat[2] * this.mat[5] * this.mat[12] - this.mat[1] * this.mat[6] * this.mat[12] - this.mat[2] * this.mat[4] * this.mat[13] + this.mat[0] * this.mat[6] * this.mat[13] + this.mat[1] * this.mat[4] * this.mat[14] - this.mat[0] * this.mat[5] * this.mat[14]) / determinant;
    inverse.mat[15] = (this.mat[1] * this.mat[6] * this.mat[8] - this.mat[2] * this.mat[5] * this.mat[8] + this.mat[2] * this.mat[4] * this.mat[9] - this.mat[0] * this.mat[6] * this.mat[9] - this.mat[1] * this.mat[4] * this.mat[10] + this.mat[0] * this.mat[5] * this.mat[10]) / determinant;
    return inverse;
  }
  invert() {
    const inverseMatrix = this.inverse();
    this.copy(inverseMatrix);
  }
  transpose() {
    return _Matrix4.fromRowMajor(
      this.mat[0],
      this.mat[1],
      this.mat[2],
      this.mat[3],
      this.mat[4],
      this.mat[5],
      this.mat[6],
      this.mat[7],
      this.mat[8],
      this.mat[9],
      this.mat[10],
      this.mat[11],
      this.mat[12],
      this.mat[13],
      this.mat[14],
      this.mat[15]
    );
  }
  setEulerAngles(x, y, z, order = "YZX") {
    const a = Math.cos(x);
    const b = Math.sin(x);
    const c = Math.cos(y);
    const d = Math.sin(y);
    const e = Math.cos(z);
    const f = Math.sin(z);
    if (order == "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      this.mat[0] = c * e;
      this.mat[4] = -c * f;
      this.mat[8] = d;
      this.mat[1] = af + be * d;
      this.mat[5] = ae - bf * d;
      this.mat[9] = -b * c;
      this.mat[2] = bf - ae * d;
      this.mat[6] = be + af * d;
      this.mat[10] = a * c;
    } else if (order == "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      this.mat[0] = ce + df * b;
      this.mat[4] = de * b - cf;
      this.mat[8] = a * d;
      this.mat[1] = a * f;
      this.mat[5] = a * e;
      this.mat[9] = -b;
      this.mat[2] = cf * b - de;
      this.mat[6] = df + ce * b;
      this.mat[10] = a * c;
    } else if (order == "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      this.mat[0] = ce - df * b;
      this.mat[4] = -a * f;
      this.mat[8] = de + cf * b;
      this.mat[1] = cf + de * b;
      this.mat[5] = a * e;
      this.mat[9] = df - ce * b;
      this.mat[2] = -a * d;
      this.mat[6] = b;
      this.mat[10] = a * c;
    } else if (order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      this.mat[0] = c * e;
      this.mat[4] = be * d - af;
      this.mat[8] = ae * d + bf;
      this.mat[1] = c * f;
      this.mat[5] = bf * d + ae;
      this.mat[9] = af * d - be;
      this.mat[2] = -d;
      this.mat[6] = b * c;
      this.mat[10] = a * c;
    } else if (order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      this.mat[0] = c * e;
      this.mat[4] = bd - ac * f;
      this.mat[8] = bc * f + ad;
      this.mat[1] = f;
      this.mat[5] = a * e;
      this.mat[9] = -b * e;
      this.mat[2] = -d * e;
      this.mat[6] = ad * f + bc;
      this.mat[10] = ac - bd * f;
    } else if (order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      this.mat[0] = c * e;
      this.mat[4] = -f;
      this.mat[8] = d * e;
      this.mat[1] = ac * f + bd;
      this.mat[5] = a * e;
      this.mat[9] = ad * f - bc;
      this.mat[2] = bc * f - ad;
      this.mat[6] = b * e;
      this.mat[10] = bd * f + ac;
    }
    this.mat[3] = 0;
    this.mat[7] = 0;
    this.mat[11] = 0;
    this.mat[12] = 0;
    this.mat[13] = 0;
    this.mat[14] = 0;
    this.mat[15] = 1;
  }
  compose(position = Vector3.ZERO, rotation = Quaternion.IDENTITY, scale = Vector3.ONE) {
    this.setTranslation(position);
    this.multiply(rotation.getMatrix());
    this.multiply(_Matrix4.makeScale(scale));
  }
  decompose() {
    const position = new Vector3();
    const rotation = new Quaternion();
    const scale = new Vector3();
    position.setPositionFromMatrix(this);
    scale.setScaleFromMatrix(this);
    const rotationMatrix = new _Matrix4();
    rotationMatrix.mat[0] = this.mat[0] / scale.x;
    rotationMatrix.mat[1] = this.mat[1] / scale.x;
    rotationMatrix.mat[2] = this.mat[2] / scale.x;
    rotationMatrix.mat[3] = 0;
    rotationMatrix.mat[4] = this.mat[4] / scale.y;
    rotationMatrix.mat[5] = this.mat[5] / scale.y;
    rotationMatrix.mat[6] = this.mat[6] / scale.y;
    rotationMatrix.mat[7] = 0;
    rotationMatrix.mat[8] = this.mat[8] / scale.z;
    rotationMatrix.mat[9] = this.mat[9] / scale.z;
    rotationMatrix.mat[10] = this.mat[10] / scale.z;
    rotationMatrix.mat[11] = 0;
    rotationMatrix.mat[12] = 0;
    rotationMatrix.mat[13] = 0;
    rotationMatrix.mat[14] = 0;
    rotationMatrix.mat[15] = 1;
    rotation.setMatrix(rotationMatrix);
    return [position, rotation, scale];
  }
};
var Matrix4 = _Matrix4;
Matrix4.IDENTITY = new _Matrix4();

// node_modules/gophergfx/src/math/BoundingBox3.ts
var BoundingBox3 = class {
  constructor() {
    this.min = new Vector3();
    this.max = new Vector3();
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
  }
  transform(translation, rotation, scale) {
    this.min.multiply(scale);
    this.max.multiply(scale);
    const corners = [];
    corners.push(new Vector3(this.min.x, this.min.y, this.min.z));
    corners.push(new Vector3(this.min.x, this.min.y, this.max.z));
    corners.push(new Vector3(this.min.x, this.max.y, this.min.z));
    corners.push(new Vector3(this.min.x, this.max.y, this.max.z));
    corners.push(new Vector3(this.max.x, this.min.y, this.min.z));
    corners.push(new Vector3(this.max.x, this.min.y, this.max.z));
    corners.push(new Vector3(this.max.x, this.max.y, this.min.z));
    corners.push(new Vector3(this.max.x, this.max.y, this.max.z));
    corners.forEach((v) => {
      v.rotate(rotation);
    });
    this.min.copy(corners[0]);
    this.max.copy(corners[0]);
    for (let i = 1; i < corners.length; i++) {
      this.min.x = Math.min(this.min.x, corners[i].x);
      this.min.y = Math.min(this.min.y, corners[i].y);
      this.min.z = Math.min(this.min.z, corners[i].z);
      this.max.x = Math.max(this.max.x, corners[i].x);
      this.max.y = Math.max(this.max.y, corners[i].y);
      this.max.z = Math.max(this.max.z, corners[i].z);
    }
    this.min.add(translation);
    this.max.add(translation);
  }
  intersects(box) {
    const thisCenter = Vector3.add(this.max, this.min);
    thisCenter.multiplyScalar(0.5);
    const otherCenter = Vector3.add(box.max, box.min);
    otherCenter.multiplyScalar(0.5);
    const thisHalfWidth = Vector3.subtract(this.max, this.min);
    thisHalfWidth.multiplyScalar(0.5);
    const otherHalfWidth = Vector3.subtract(box.max, box.min);
    otherHalfWidth.multiplyScalar(0.5);
    if (Math.abs(thisCenter.x - otherCenter.x) > thisHalfWidth.x + otherHalfWidth.x)
      return false;
    else if (Math.abs(thisCenter.y - otherCenter.y) > thisHalfWidth.y + otherHalfWidth.y)
      return false;
    else if (Math.abs(thisCenter.z - otherCenter.z) > thisHalfWidth.z + otherHalfWidth.z)
      return false;
    else
      return true;
  }
  computeBounds(vertices) {
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      this.max.set(vArray[0], vArray[1], vArray[2]);
      this.min.set(vArray[0], vArray[1], vArray[2]);
      for (let i = 0; i < vArray.length; i += 3) {
        if (vArray[i] > this.max.x)
          this.max.x = vArray[i];
        if (vArray[i] < this.min.x)
          this.min.x = vArray[i];
        if (vArray[i + 1] > this.max.y)
          this.max.y = vArray[i + 1];
        if (vArray[i + 1] < this.min.y)
          this.min.y = vArray[i + 1];
        if (vArray[i + 2] > this.max.z)
          this.max.z = vArray[i + 2];
        if (vArray[i + 2] < this.min.z)
          this.min.z = vArray[i + 2];
      }
    } else {
      this.max.copy(vertices[0]);
      this.min.copy(vertices[0]);
      vertices.forEach((elem) => {
        if (elem.x > this.max.x)
          this.max.x = elem.x;
        if (elem.x < this.min.x)
          this.min.x = elem.x;
        if (elem.y > this.max.y)
          this.max.y = elem.y;
        if (elem.y < this.min.y)
          this.min.y = elem.y;
        if (elem.z > this.max.z)
          this.max.z = elem.z;
        if (elem.z < this.min.z)
          this.min.z = elem.z;
      });
    }
  }
};

// node_modules/gophergfx/src/math/BoundingSphere.ts
var BoundingSphere = class {
  constructor() {
    this.center = new Vector3();
    this.radius = 0;
  }
  copy(circle) {
    this.center.copy(circle.center);
    this.radius = circle.radius;
  }
  transform(translation, scale) {
    this.center.multiply(scale);
    this.center.add(translation);
    if (scale.x >= scale.y)
      this.radius *= scale.x;
    else
      this.radius *= scale.y;
  }
  intersects(circle) {
    const distance = this.center.distanceTo(circle.center);
    if (distance < this.radius + circle.radius)
      return true;
    else
      return false;
  }
  computeBounds(vertices, boundingBox) {
    this.center.copy(boundingBox.min);
    this.center.add(boundingBox.max);
    this.center.multiplyScalar(0.5);
    this.radius = 0;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      for (let i = 0; i < vArray.length; i += 3) {
        const distance = Math.sqrt(
          (vArray[i] - this.center.x) * (vArray[i] - this.center.x) + (vArray[i + 1] - this.center.y) * (vArray[i + 1] - this.center.y) + (vArray[i + 2] - this.center.z) * (vArray[i + 2] - this.center.z)
        );
        if (distance > this.radius)
          this.radius = distance;
      }
    } else {
      vertices.forEach((elem) => {
        const distance = elem.distanceTo(this.center);
        if (distance > this.radius)
          this.radius = distance;
      });
    }
  }
};

// node_modules/gophergfx/src/core/Transform3.ts
var IntersectionMode3 = /* @__PURE__ */ ((IntersectionMode32) => {
  IntersectionMode32[IntersectionMode32["BOUNDING_SPHERE"] = 0] = "BOUNDING_SPHERE";
  IntersectionMode32[IntersectionMode32["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  return IntersectionMode32;
})(IntersectionMode3 || {});
var Transform3 = class {
  constructor() {
    this.children = [];
    this.position = new Vector3();
    this.rotation = new Quaternion();
    this.scale = new Vector3(1, 1, 1);
    this.visible = true;
    this.autoUpdateMatrix = true;
    this.matrix = new Matrix4();
    this.worldMatrix = new Matrix4();
    this.parent = null;
    this.boundingBox = new BoundingBox3();
    this.boundingSphere = new BoundingSphere();
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  traverseSceneGraph() {
    if (this.autoUpdateMatrix) {
      this.matrix.compose(this.position, this.rotation, this.scale);
    }
    if (this.parent) {
      this.worldMatrix.copy(this.parent.worldMatrix);
      this.worldMatrix.multiply(this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
    this.children.forEach((elem) => {
      elem.traverseSceneGraph();
    });
  }
  updateWorldMatrix() {
    if (this.autoUpdateMatrix) {
      this.matrix.compose(this.position, this.rotation, this.scale);
    }
    if (this.parent) {
      this.parent.updateWorldMatrix();
      this.worldMatrix.copy(this.parent.worldMatrix);
      this.worldMatrix.multiply(this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
  }
  add(child) {
    this.children.push(child);
    child.parent = this;
  }
  remove() {
    if (this.parent == null)
      return false;
    else
      return this.parent.removeChild(this) != null;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index == -1) {
      return null;
    } else {
      const removedElement = this.children.splice(index, 1);
      removedElement[0].parent = null;
      return removedElement[0];
    }
  }
  setLights(lightManager) {
    this.children.forEach((elem) => {
      elem.setLights(lightManager);
    });
  }
  translate(translation) {
    this.position.add(Vector3.rotate(translation, this.rotation));
  }
  translateX(distance) {
    this.position.add(Vector3.rotate(new Vector3(distance, 0, 0), this.rotation));
  }
  translateY(distance) {
    this.position.add(Vector3.rotate(new Vector3(0, distance, 0), this.rotation));
  }
  translateZ(distance) {
    this.position.add(Vector3.rotate(new Vector3(0, 0, distance), this.rotation));
  }
  rotate(rotation) {
    this.rotation.multiply(Quaternion.makeEulerAngles(rotation.x, rotation.y, rotation.z));
  }
  rotateX(angle) {
    this.rotation.multiply(Quaternion.makeRotationX(angle));
  }
  rotateY(angle) {
    this.rotation.multiply(Quaternion.makeRotationY(angle));
  }
  rotateZ(angle) {
    this.rotation.multiply(Quaternion.makeRotationZ(angle));
  }
  lookAt(target, up = Vector3.UP) {
    this.updateWorldMatrix();
    const [worldPosition, worldRotation, worldScale] = this.worldMatrix.decompose();
    this.rotation.lookAt(worldPosition, target, up);
  }
  intersects(other, mode = 0 /* BOUNDING_SPHERE */) {
    if (mode == 0 /* BOUNDING_SPHERE */) {
      const thisSphere = new BoundingSphere();
      thisSphere.copy(this.boundingSphere);
      thisSphere.transform(this.position, this.scale);
      const otherSphere = new BoundingSphere();
      otherSphere.copy(other.boundingSphere);
      otherSphere.transform(other.position, other.scale);
      return thisSphere.intersects(otherSphere);
    } else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */) {
      const thisBox = new BoundingBox3();
      thisBox.copy(this.boundingBox);
      thisBox.transform(this.position, this.rotation, this.scale);
      const otherBox = new BoundingBox3();
      otherBox.copy(other.boundingBox);
      otherBox.transform(other.position, other.rotation, other.scale);
      return thisBox.intersects(otherBox);
    } else {
      return false;
    }
  }
};

// node_modules/gophergfx/src/core/Camera.ts
var Camera = class extends Transform3 {
  constructor() {
    super();
    this.fov = 0;
    this.aspectRatio = 0;
    this.near = 0;
    this.far = 0;
    this.left = 0;
    this.right = 0;
    this.projectionMatrixDirty = true;
    this.projectionMatrix = new Matrix4();
    this.viewMatrix = new Matrix4();
  }
  setPerspectiveCamera(fov, aspectRatio, near, far) {
    this.fov = fov;
    this.aspectRatio = aspectRatio;
    this.near = near;
    this.far = far;
    this.projectionMatrixDirty = true;
    this.projectionMatrix.setPerspective(fov, aspectRatio, near, far);
  }
  setOrthographicCamera(left, right, bottom, top, near, far) {
    this.left = left;
    this.right = right;
    this.aspectRatio = Math.abs((right - left) / (top - bottom));
    this.near = near;
    this.far = far;
    this.projectionMatrixDirty = true;
    this.projectionMatrix.setOrthographic(left, right, bottom, top, near, far);
  }
  updateWorldMatrix() {
    super.updateWorldMatrix();
    this.viewMatrix = this.worldMatrix.inverse();
  }
  getAspectRatio() {
    return this.aspectRatio;
  }
  getNear() {
    return this.near;
  }
  getFar() {
    return this.far;
  }
  getLeft() {
    return this.left;
  }
  getRight() {
    return this.right;
  }
};

// node_modules/gophergfx/src/math/Matrix3.ts
var _Matrix3 = class {
  static multiply(m1, m2) {
    const m = new _Matrix3();
    m.mat[0] = m1.mat[0] * m2.mat[0] + m1.mat[1] * m2.mat[3] + m1.mat[2] * m2.mat[6];
    m.mat[1] = m1.mat[0] * m2.mat[1] + m1.mat[1] * m2.mat[4] + m1.mat[2] * m2.mat[7];
    m.mat[2] = m1.mat[0] * m2.mat[2] + m1.mat[1] * m2.mat[5] + m1.mat[2] * m2.mat[8];
    m.mat[3] = m1.mat[3] * m2.mat[0] + m1.mat[4] * m2.mat[3] + m1.mat[5] * m2.mat[6];
    m.mat[4] = m1.mat[3] * m2.mat[1] + m1.mat[4] * m2.mat[4] + m1.mat[5] * m2.mat[7];
    m.mat[5] = m1.mat[3] * m2.mat[2] + m1.mat[4] * m2.mat[5] + m1.mat[5] * m2.mat[8];
    m.mat[6] = m1.mat[6] * m2.mat[0] + m1.mat[7] * m2.mat[3] + m1.mat[8] * m2.mat[6];
    m.mat[7] = m1.mat[6] * m2.mat[1] + m1.mat[7] * m2.mat[4] + m1.mat[8] * m2.mat[7];
    m.mat[8] = m1.mat[6] * m2.mat[2] + m1.mat[7] * m2.mat[5] + m1.mat[8] * m2.mat[8];
    return m;
  }
  static copy(m) {
    const mat = new _Matrix3();
    mat.copy(m);
    return mat;
  }
  static fromRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    const matrix = new _Matrix3();
    matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);
    return matrix;
  }
  static fromColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    const matrix = new _Matrix3();
    matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);
    return matrix;
  }
  static makeTranslation(v) {
    return _Matrix3.fromRowMajor(
      1,
      0,
      v.x,
      0,
      1,
      v.y,
      0,
      0,
      1
    );
  }
  static makeRotation(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    return _Matrix3.fromRowMajor(
      cosTheta,
      -sinTheta,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      1
    );
  }
  static makeScale(scale) {
    return _Matrix3.fromRowMajor(
      scale.x,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      1
    );
  }
  static compose(position = Vector2.ZERO, rotation = 0, scale = Vector2.ONE) {
    const matrix = new _Matrix3();
    matrix.compose(position, rotation, scale);
    return matrix;
  }
  constructor() {
    this.mat = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    this.mat[0] = n1;
    this.mat[1] = n2;
    this.mat[2] = n3;
    this.mat[3] = n4;
    this.mat[4] = n5;
    this.mat[5] = n6;
    this.mat[6] = n7;
    this.mat[7] = n8;
    this.mat[8] = n9;
  }
  setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    this.mat[0] = n1;
    this.mat[1] = n4;
    this.mat[2] = n7;
    this.mat[3] = n2;
    this.mat[4] = n5;
    this.mat[5] = n8;
    this.mat[6] = n3;
    this.mat[7] = n6;
    this.mat[8] = n9;
  }
  copy(m) {
    for (let i = 0; i < 9; i++)
      this.mat[i] = m.mat[i];
  }
  element(row, col) {
    return this.mat[col * 3 + row];
  }
  set(value, row, col) {
    this.mat[col * 3 + row] = value;
  }
  multiply(m) {
    const temp = _Matrix3.multiply(m, this);
    this.copy(temp);
  }
  setTranslation(v) {
    this.setRowMajor(
      1,
      0,
      v.x,
      0,
      1,
      v.y,
      0,
      0,
      1
    );
  }
  setRotation(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      -sinTheta,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      1
    );
  }
  setScale(scale) {
    this.setRowMajor(
      scale.x,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      1
    );
  }
  multiplyScalar(x) {
    for (let i = 0; i < 9; i++)
      this.mat[i] *= x;
  }
  inverse() {
    const inverse = new _Matrix3();
    const det = this.mat[0] * this.mat[4] * this.mat[8] + this.mat[1] * this.mat[5] * this.mat[6] + this.mat[2] * this.mat[3] * this.mat[7] - this.mat[0] * this.mat[5] * this.mat[7] - this.mat[1] * this.mat[3] * this.mat[8] - this.mat[2] * this.mat[4] * this.mat[6];
    this.mat[0] = (this.mat[4] * this.mat[8] - this.mat[5] * this.mat[7]) / det;
    this.mat[1] = (this.mat[2] * this.mat[7] - this.mat[1] * this.mat[8]) / det;
    this.mat[2] = (this.mat[1] * this.mat[5] - this.mat[2] * this.mat[4]) / det;
    this.mat[3] = (this.mat[5] * this.mat[6] - this.mat[3] * this.mat[8]) / det;
    this.mat[4] = (this.mat[0] * this.mat[8] - this.mat[2] * this.mat[6]) / det;
    this.mat[5] = (this.mat[2] * this.mat[3] - this.mat[0] * this.mat[5]) / det;
    this.mat[6] = (this.mat[3] * this.mat[7] - this.mat[4] * this.mat[6]) / det;
    this.mat[7] = (this.mat[1] * this.mat[6] - this.mat[0] * this.mat[7]) / det;
    this.mat[8] = (this.mat[0] * this.mat[4] - this.mat[1] * this.mat[3]) / det;
    return inverse;
  }
  invert() {
    const inverseMatrix = this.inverse();
    this.copy(inverseMatrix);
  }
  transpose() {
    return _Matrix3.fromRowMajor(
      this.mat[0],
      this.mat[1],
      this.mat[2],
      this.mat[3],
      this.mat[4],
      this.mat[5],
      this.mat[6],
      this.mat[7],
      this.mat[8]
    );
  }
  compose(position = Vector2.ZERO, rotation = 0, scale = Vector2.ONE) {
    this.setTranslation(position);
    this.multiply(_Matrix3.makeRotation(rotation));
    this.multiply(_Matrix3.makeScale(scale));
  }
  decompose() {
    const position = new Vector2();
    const scale = new Vector2();
    position.setPositionFromMatrix(this);
    scale.setScaleFromMatrix(this);
    return [position, Math.atan2(this.mat[1], this.mat[0]), scale];
  }
};
var Matrix3 = _Matrix3;
Matrix3.IDENTITY = new _Matrix3();

// node_modules/gophergfx/src/math/BoundingBox2.ts
var BoundingBox2 = class {
  constructor() {
    this.min = new Vector2();
    this.max = new Vector2();
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
  }
  transform(translation, rotation, scale) {
    this.min.multiply(scale);
    this.max.multiply(scale);
    const topLeft = new Vector2(this.min.x, this.max.y);
    const topRight = new Vector2(this.max.x, this.max.y);
    const bottomLeft = new Vector2(this.min.x, this.min.y);
    const bottomRight = new Vector2(this.max.x, this.min.y);
    topLeft.rotate(rotation);
    topRight.rotate(rotation);
    bottomLeft.rotate(rotation);
    bottomRight.rotate(rotation);
    this.min.x = Math.min(topLeft.x, Math.min(topRight.x, Math.min(bottomLeft.x, bottomRight.x)));
    this.min.y = Math.min(topLeft.y, Math.min(topRight.y, Math.min(bottomLeft.y, bottomRight.y)));
    this.max.x = Math.max(topLeft.x, Math.max(topRight.x, Math.max(bottomLeft.x, bottomRight.x)));
    this.max.y = Math.max(topLeft.y, Math.max(topRight.y, Math.max(bottomLeft.y, bottomRight.y)));
    this.min.add(translation);
    this.max.add(translation);
  }
  intersects(box) {
    const thisCenter = Vector2.add(this.max, this.min);
    thisCenter.multiplyScalar(0.5);
    const otherCenter = Vector2.add(box.max, box.min);
    otherCenter.multiplyScalar(0.5);
    const thisHalfWidth = Vector2.subtract(this.max, this.min);
    thisHalfWidth.multiplyScalar(0.5);
    const otherHalfWidth = Vector2.subtract(box.max, box.min);
    otherHalfWidth.multiplyScalar(0.5);
    if (Math.abs(thisCenter.x - otherCenter.x) > thisHalfWidth.x + otherHalfWidth.x)
      return false;
    else if (Math.abs(thisCenter.y - otherCenter.y) > thisHalfWidth.y + otherHalfWidth.y)
      return false;
    else
      return true;
  }
};

// node_modules/gophergfx/src/math/BoundingCircle.ts
var BoundingCircle = class {
  constructor() {
    this.center = new Vector2();
    this.radius = 0;
  }
  copy(circle) {
    this.center.copy(circle.center);
    this.radius = circle.radius;
  }
  transform(translation, scale) {
    this.center.multiply(scale);
    this.center.add(translation);
    if (scale.x >= scale.y)
      this.radius *= scale.x;
    else
      this.radius *= scale.y;
  }
  intersects(circle) {
    const distance = this.center.distanceTo(circle.center);
    if (distance < this.radius + circle.radius)
      return true;
    else
      return false;
  }
};

// node_modules/gophergfx/src/core/Transform2.ts
var IntersectionMode2 = /* @__PURE__ */ ((IntersectionMode22) => {
  IntersectionMode22[IntersectionMode22["BOUNDING_CIRCLE"] = 0] = "BOUNDING_CIRCLE";
  IntersectionMode22[IntersectionMode22["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  return IntersectionMode22;
})(IntersectionMode2 || {});
var Transform2 = class {
  constructor() {
    this.children = [];
    this.position = new Vector2();
    this.rotation = 0;
    this.scale = new Vector2(1, 1);
    this.autoUpdateMatrix = true;
    this.matrix = new Matrix3();
    this.worldMatrix = new Matrix3();
    this.layer = 0;
    this.visible = true;
    this.parent = null;
    this.boundingBox = new BoundingBox2();
    this.boundingCircle = new BoundingCircle();
  }
  draw() {
    if (!this.visible)
      return;
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
  traverseSceneGraph() {
    if (this.autoUpdateMatrix) {
      this.matrix.compose(this.position, this.rotation, this.scale);
    }
    if (this.parent) {
      this.worldMatrix.copy(this.parent.worldMatrix);
      this.worldMatrix.multiply(this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
    this.children.forEach((elem) => {
      elem.traverseSceneGraph();
    });
  }
  updateWorldMatrix() {
    if (this.autoUpdateMatrix) {
      this.matrix.compose(this.position, this.rotation, this.scale);
    }
    if (this.parent) {
      this.parent.updateWorldMatrix();
      this.worldMatrix.copy(this.parent.worldMatrix);
      this.worldMatrix.multiply(this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
  }
  add(child) {
    this.children.push(child);
    child.parent = this;
  }
  remove() {
    if (this.parent == null)
      return false;
    else
      return this.parent.removeChild(this) != null;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index == -1) {
      return null;
    } else {
      const removedElement = this.children.splice(index, 1);
      removedElement[0].parent = null;
      return removedElement[0];
    }
  }
  translate(translation) {
    const localVector = Vector2.rotate(translation, this.rotation);
    this.position.add(localVector);
  }
  translateX(distance) {
    const localVector = Vector2.rotate(new Vector2(distance, 0), this.rotation);
    this.position.add(localVector);
  }
  translateY(distance) {
    const localVector = Vector2.rotate(new Vector2(0, distance), this.rotation);
    this.position.add(localVector);
  }
  lookAt(target, lookVector = Vector2.UP) {
    this.updateWorldMatrix();
    const [worldPosition, worldRotation, worldScale] = this.worldMatrix.decompose();
    const targetVector = Vector2.subtract(target, worldPosition);
    if (targetVector.length() > 0) {
      const worldLookVector = Vector2.rotate(lookVector, worldRotation);
      this.rotation += worldLookVector.angleBetweenSigned(targetVector);
    }
  }
  intersects(other, mode = 0 /* BOUNDING_CIRCLE */) {
    if (mode == 0 /* BOUNDING_CIRCLE */) {
      const thisCircle = new BoundingCircle();
      thisCircle.copy(this.boundingCircle);
      thisCircle.transform(this.position, this.scale);
      const otherCircle = new BoundingCircle();
      otherCircle.copy(other.boundingCircle);
      otherCircle.transform(other.position, other.scale);
      return thisCircle.intersects(otherCircle);
    } else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */) {
      const thisBox = new BoundingBox2();
      thisBox.copy(this.boundingBox);
      thisBox.transform(this.position, this.rotation, this.scale);
      const otherBox = new BoundingBox2();
      otherBox.copy(other.boundingBox);
      otherBox.transform(other.position, other.rotation, other.scale);
      return thisBox.intersects(otherBox);
    } else {
      return false;
    }
  }
};

// node_modules/gophergfx/src/lights/LightManager.ts
var LightManager = class {
  constructor() {
    this.lights = [];
    this.lightTypes = [];
    this.lightPositions = [];
    this.ambientIntensities = [];
    this.diffuseIntensities = [];
    this.specularIntensities = [];
  }
  clear() {
    this.lights = [];
    this.lightTypes = [];
    this.lightPositions = [];
    this.ambientIntensities = [];
    this.diffuseIntensities = [];
    this.specularIntensities = [];
  }
  addLight(light) {
    const alreadyAdded = this.lights.some((elem) => {
      return elem == light;
    });
    if (!alreadyAdded)
      this.lights.push(light);
  }
  getNumLights() {
    return this.lights.length;
  }
  updateLights() {
    this.lights.forEach((light) => {
      const [worldPosition, worldRotation, worldScale] = light.worldMatrix.decompose();
      this.lightPositions.push(worldPosition.x, worldPosition.y, worldPosition.z);
      this.lightTypes.push(light.getType());
      if (light.visible) {
        this.ambientIntensities.push(light.ambientIntensity.x, light.ambientIntensity.y, light.ambientIntensity.z);
        this.diffuseIntensities.push(light.diffuseIntensity.x, light.diffuseIntensity.y, light.diffuseIntensity.z);
        this.specularIntensities.push(light.specularIntensity.x, light.specularIntensity.y, light.specularIntensity.z);
      } else {
        this.ambientIntensities.push(0, 0, 0);
        this.diffuseIntensities.push(0, 0, 0);
        this.specularIntensities.push(0, 0, 0);
      }
    });
  }
};

// node_modules/gophergfx/src/core/Scene.ts
var Scene = class {
  constructor() {
    this.root3d = new Transform3();
    this.root2d = new Transform2();
    this.lightManager = new LightManager();
  }
  draw(camera) {
    camera.updateWorldMatrix();
    this.lightManager.clear();
    this.root3d.setLights(this.lightManager);
    this.lightManager.updateLights();
    this.root3d.children.forEach((elem) => {
      elem.draw(this.root3d, camera, this.lightManager);
    });
    this.root2d.children.forEach((elem) => {
      elem.draw();
    });
  }
  add(child) {
    if (child instanceof Transform3) {
      this.root3d.add(child);
    } else {
      this.root2d.add(child);
    }
  }
  traverseSceneGraph() {
    this.root3d.children.forEach((elem) => {
      elem.traverseSceneGraph();
    });
    this.root2d.children.forEach((elem) => {
      elem.traverseSceneGraph();
    });
  }
};

// node_modules/gophergfx/src/loaders/AssetManager.ts
var AssetManager = class {
  constructor() {
    this.requestedAssets = [];
    this.loadedAssets = [];
    this.errorAssets = [];
  }
  allAssetsLoaded() {
    return this.requestedAssets.length == this.loadedAssets.length + this.errorAssets.length;
  }
};

// node_modules/gophergfx/src/core/GfxApp.ts
var GfxApp = class {
  static getInstance() {
    return GfxApp.instance;
  }
  constructor(enableStencilBuffer = false) {
    GfxApp.instance = this;
    this.time = Date.now();
    this.paused = false;
    this.camera = new Camera();
    this.scene = new Scene();
    this.renderer = new Renderer(enableStencilBuffer);
    this.assetManager = new AssetManager();
    this.runInBackground = false;
    this.previousTouches = [new Vector2()];
    window.addEventListener("resize", () => {
      this.resize();
    }, false);
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("wheel", (event) => {
      this.onMouseWheel(event);
    });
    window.addEventListener("keydown", (event) => {
      this.onKeyDown(event);
    });
    window.addEventListener("keyup", (event) => {
      this.onKeyUp(event);
    });
    window.addEventListener("focus", (event) => {
      this.onFocusReceived(event);
    });
    window.addEventListener("blur", (event) => {
      this.onFocusLost(event);
    });
    window.addEventListener("touchstart", (event) => {
      this.onTouchStart(event);
    }, { passive: false });
    window.addEventListener("touchmove", (event) => {
      this.onTouchMove(event);
    }, { passive: false });
    window.addEventListener("touchend", (event) => {
      this.onTouchEnd(event);
    }, { passive: false });
    window.addEventListener("touchcancel", (event) => {
      this.onTouchEnd(event);
    }, { passive: false });
    window.addEventListener("contextmenu", (event) => event.preventDefault());
    this.camera.setOrthographicCamera(0, 1, 0, 1, 0.01, 1);
  }
  start() {
    this.createScene();
    this.initializationLoop();
  }
  initializationLoop() {
    if (!this.assetManager.allAssetsLoaded()) {
      window.requestAnimationFrame(() => this.initializationLoop());
    } else {
      this.onAssetsLoaded();
      this.time = Date.now();
      this.mainLoop();
    }
  }
  mainLoop() {
    if (this.runInBackground || !this.paused) {
      const deltaTime = (Date.now() - this.time) / 1e3;
      this.time = Date.now();
      this.update(deltaTime);
      this.scene.traverseSceneGraph();
      this.lateUpdate(deltaTime);
      this.renderer.render(this.scene, this.camera);
    }
    window.requestAnimationFrame(() => this.mainLoop());
  }
  resize() {
    this.renderer.resize(window.innerWidth, window.innerHeight, this.camera.getAspectRatio());
  }
  onTouchStart(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mousedown", event);
  }
  onTouchMove(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mousemove", event);
    else
      this.simulateWheelEvent(event);
  }
  onTouchEnd(event) {
    event.preventDefault();
    if (event.touches.length == 0)
      this.simulateMouseEvent("mouseup", event);
  }
  onFocusReceived(event) {
    this.resume();
  }
  onFocusLost(event) {
    this.pause();
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.time = Date.now();
    this.paused = false;
  }
  isPaused() {
    return this.paused;
  }
  getNormalizedDeviceCoordinates(mouseX, mouseY) {
    return this.renderer.getNormalizedDeviceCoordinates(mouseX, mouseY);
  }
  simulateMouseEvent(type, touchEvent) {
    if (this.previousTouches.length == 1) {
      const mouseEvent = new MouseEvent(type, {
        "button": 0,
        "buttons": 1,
        "clientX": touchEvent.changedTouches[0].clientX,
        "clientY": touchEvent.changedTouches[0].clientY,
        "screenX": touchEvent.changedTouches[0].screenX,
        "screenY": touchEvent.changedTouches[0].screenY,
        "movementX": touchEvent.changedTouches[0].clientX - this.previousTouches[0].x,
        "movementY": touchEvent.changedTouches[0].clientY - this.previousTouches[0].y,
        "view": touchEvent.view,
        cancelable: true,
        bubbles: true
      });
      touchEvent.target.dispatchEvent(mouseEvent);
    }
    this.previousTouches = [new Vector2(touchEvent.changedTouches[0].clientX, touchEvent.changedTouches[0].clientY)];
  }
  simulateWheelEvent(touchEvent) {
    if (this.previousTouches.length > 1) {
      const previousDistance = this.previousTouches[0].distanceTo(this.previousTouches[1]);
      const currentDistance = Math.sqrt(
        (touchEvent.touches[0].clientX - touchEvent.touches[1].clientX) * (touchEvent.touches[0].clientX - touchEvent.touches[1].clientX) + (touchEvent.touches[0].clientY - touchEvent.touches[1].clientY) * (touchEvent.touches[0].clientY - touchEvent.touches[1].clientY)
      );
      let scaleFactor = 0;
      if (currentDistance > previousDistance)
        scaleFactor = -currentDistance / previousDistance;
      else if (currentDistance < previousDistance)
        scaleFactor = previousDistance / currentDistance;
      const wheelEvent = new WheelEvent("wheel", {
        "clientX": (touchEvent.touches[0].clientX + touchEvent.touches[1].clientX) / 2,
        "clientY": (touchEvent.touches[0].clientY + touchEvent.touches[1].clientY) / 2,
        "screenX": (touchEvent.touches[0].screenX + touchEvent.touches[1].screenX) / 2,
        "screenY": (touchEvent.touches[0].screenY + touchEvent.touches[1].screenY) / 2,
        "movementX": (touchEvent.touches[0].clientX - this.previousTouches[0].x + (touchEvent.touches[1].clientX - this.previousTouches[1].x)) / 2,
        "movementY": (touchEvent.touches[0].clientY - this.previousTouches[0].y + (touchEvent.touches[1].clientY - this.previousTouches[1].y)) / 2,
        "deltaX": 0,
        "deltaY": 50 * scaleFactor,
        "deltaZ": 0,
        "deltaMode": WheelEvent.DOM_DELTA_PIXEL,
        "view": touchEvent.view,
        cancelable: true,
        bubbles: true
      });
      touchEvent.target.dispatchEvent(wheelEvent);
    }
    this.previousTouches = [];
    for (let i = 0; i < touchEvent.changedTouches.length; i++) {
      this.previousTouches.push(new Vector2(touchEvent.touches[i].clientX, touchEvent.touches[i].clientY));
    }
  }
  lateUpdate(deltaTime) {
  }
  onAssetsLoaded() {
  }
  onMouseDown(event) {
  }
  onMouseUp(event) {
  }
  onMouseMove(event) {
  }
  onMouseWheel(event) {
  }
  onKeyDown(event) {
  }
  onKeyUp(event) {
  }
};

// node_modules/gophergfx/src/shaders/gouraud.vert
var gouraud_default = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 8;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the final vertex position and normal\n    vec3 worldPosition = (modelMatrix * vec4(position, 1)).xyz;\n    vec3 worldNormal = normalize((normalMatrix * vec4(normal, 0)).xyz);\n\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - worldPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(worldNormal, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - worldPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, worldNormal);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    vertColor = color;\n    vertColor.rgb *= illumination;\n\n    uv = texCoord.xy; \n\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/gouraud.frag
var gouraud_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/Material3.ts
var Side = /* @__PURE__ */ ((Side2) => {
  Side2[Side2["FRONT"] = 0] = "FRONT";
  Side2[Side2["BACK"] = 1] = "BACK";
  Side2[Side2["DOUBLE"] = 2] = "DOUBLE";
  return Side2;
})(Side || {});
var Material3 = class {
  constructor() {
    this.visible = true;
    this.side = 0 /* FRONT */;
    this.gl = GfxApp.getInstance().renderer.gl;
  }
  initialize() {
    if (this.side == 2 /* DOUBLE */) {
      this.gl.disable(this.gl.CULL_FACE);
      return;
    }
    this.gl.enable(this.gl.CULL_FACE);
    if (this.side == 0 /* FRONT */)
      this.gl.cullFace(this.gl.BACK);
    else
      this.gl.cullFace(this.gl.FRONT);
  }
};

// node_modules/gophergfx/src/materials/ShaderProgram.ts
var ShaderProgram = class {
  constructor(vertexSource, fragmentSource) {
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.shaderProgram = null;
    this.initialized = false;
  }
  initialize(gl) {
    if (this.initialized)
      return;
    this.initialized = true;
    this.vertexShader = this.createVertexShader(gl, this.vertexSource);
    this.fragmentShader = this.createFragmentShader(gl, this.fragmentSource);
    if (this.vertexShader && this.fragmentShader)
      this.shaderProgram = this.createShaderProgram(gl, this.vertexShader, this.fragmentShader);
  }
  createVertexShader(gl, source) {
    const shader = gl.createShader(gl.VERTEX_SHADER);
    if (!shader) {
      console.error("Error: unable to create vertex shader");
    } else {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error: unable to load vertex shader");
        console.error(gl.getShaderInfoLog(shader));
      }
    }
    return shader;
  }
  createFragmentShader(gl, source) {
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    if (!shader) {
      console.error("Error: unable to create fragment shader");
    } else {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error: unable to load fragment shader");
        console.error(gl.getShaderInfoLog(shader));
      }
    }
    return shader;
  }
  createShaderProgram(gl, vertexShader, fragmentShader) {
    let program = null;
    if (vertexShader && fragmentShader) {
      program = gl.createProgram();
      if (!program) {
        console.error("Error: could not create shader program");
        return null;
      }
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Error: could not link shader program");
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
    }
    return program;
  }
  getProgram() {
    return this.shaderProgram;
  }
  getAttribute(gl, attribute) {
    if (this.shaderProgram)
      return gl.getAttribLocation(this.shaderProgram, attribute);
    else
      return -1;
  }
  getUniform(gl, uniform) {
    if (this.shaderProgram)
      return gl.getUniformLocation(this.shaderProgram, uniform);
    else
      return null;
  }
};

// node_modules/gophergfx/src/materials/GouraudMaterial.ts
var _GouraudMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _GouraudMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _GouraudMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _GouraudMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _GouraudMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _GouraudMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _GouraudMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _GouraudMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _GouraudMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _GouraudMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _GouraudMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _GouraudMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _GouraudMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _GouraudMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _GouraudMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _GouraudMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_GouraudMaterial.shader.getProgram());
    const cameraPosition = new Vector3();
    cameraPosition.transform(camera.worldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, transform.worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, transform.worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.ambientColor.copy(color);
    this.diffuseColor.copy(color);
    this.specularColor.copy(color);
  }
};
var GouraudMaterial = _GouraudMaterial;
GouraudMaterial.shader = new ShaderProgram(gouraud_default, gouraud_default2);

// node_modules/gophergfx/src/geometry/3d/Mesh.ts
var Mesh = class extends Transform3 {
  constructor() {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.normalBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.indexBuffer = this.gl.createBuffer();
    this.texCoordBuffer = this.gl.createBuffer();
    this.morphTargetPositionBuffer = this.gl.createBuffer();
    this.morphTargetNormalBuffer = this.gl.createBuffer();
    this.vertexCount = 0;
    this.triangleCount = 0;
    this.positionCache = null;
    this.normalCache = null;
    this.colorCache = null;
    this.indexCache = null;
    this.texCoordCache = null;
    this.material = new GouraudMaterial();
    this.morphTargetBoundingBox = new BoundingBox3();
    this.morphTargetBoundingSphere = new BoundingSphere();
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.material.draw(this, this, camera, lightManager);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  setVertices(vertices, dynamicDraw = false) {
    this.positionCache = null;
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      if (typeof vertices[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
        this.vertexCount = vertices.length / 3;
        this.boundingBox.computeBounds(vertices);
        this.boundingSphere.computeBounds(vertices, this.boundingBox);
      } else {
        const vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.STATIC_DRAW);
        this.vertexCount = vertices.length;
        this.boundingBox.computeBounds(vArray);
        this.boundingSphere.computeBounds(vArray, this.boundingBox);
      }
    }
  }
  setNormals(normals, dynamicDraw = false) {
    this.normalCache = null;
    if (normals.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
      if (typeof normals[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
      } else {
        const nArray = [];
        normals.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setColors(colors, dynamicDraw = false) {
    this.colorCache = null;
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setTextureCoordinates(texCoords, dynamicDraw = false) {
    this.texCoordCache = null;
    if (texCoords.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      if (typeof texCoords[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), this.gl.STATIC_DRAW);
      } else {
        const tArray = [];
        texCoords.forEach((elem) => {
          tArray.push(elem.x, elem.y);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setIndices(indices, dynamicDraw = false) {
    this.indexCache = null;
    if (indices.length > 0) {
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      if (typeof indices[0] === "number") {
        this.triangleCount = indices.length / 3;
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);
      } else {
        this.triangleCount = indices.length;
        const iArray = [];
        indices.forEach((elem) => {
          iArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setArrayBuffer(values, buffer, dynamicDraw = false) {
    if (values.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      if (typeof values[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), this.gl.STATIC_DRAW);
      } else {
        const nArray = [];
        values.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);
      }
    }
  }
  setMorphTargetVertices(vertices, dynamicDraw = false, computeBounds = true) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.morphTargetPositionBuffer);
      if (typeof vertices[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
        this.morphTargetBoundingBox.computeBounds(vertices);
        this.morphTargetBoundingSphere.computeBounds(vertices, this.morphTargetBoundingBox);
      } else {
        const vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), this.gl.STATIC_DRAW);
        this.morphTargetBoundingBox.computeBounds(vArray);
        this.morphTargetBoundingSphere.computeBounds(vArray, this.morphTargetBoundingBox);
      }
    }
  }
  setMorphTargetNormals(normals, dynamicDraw = false) {
    if (normals.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.morphTargetNormalBuffer);
      if (typeof normals[0] === "number") {
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), this.gl.STATIC_DRAW);
      } else {
        const nArray = [];
        normals.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        if (dynamicDraw)
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.DYNAMIC_DRAW);
        else
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), this.gl.STATIC_DRAW);
      }
    }
  }
  getVertices() {
    if (!this.positionCache) {
      const vertexArray = new Float32Array(this.vertexCount * 3);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
      this.positionCache = [...vertexArray];
    }
    return this.positionCache;
  }
  getNormals() {
    if (!this.normalCache) {
      const normalArray = new Float32Array(this.vertexCount * 3);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, normalArray);
      this.normalCache = [...normalArray];
    }
    return this.normalCache;
  }
  getColors() {
    if (!this.colorCache) {
      const colorArray = new Float32Array(this.vertexCount * 4);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
      this.colorCache = [...colorArray];
    }
    return this.colorCache;
  }
  getTextureCoordinates() {
    if (!this.texCoordCache) {
      const texCoordArray = new Float32Array(this.vertexCount * 2);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, texCoordArray);
      this.texCoordCache = [...texCoordArray];
    }
    return this.texCoordCache;
  }
  getIndices() {
    if (!this.indexCache) {
      const indexArray = new Uint16Array(this.triangleCount * 3);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);
      this.indexCache = [...indexArray];
    }
    return this.indexCache;
  }
  getArrayBuffer(buffer) {
    const valueArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, valueArray);
    return [...valueArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  computeBounds(vertices) {
    if (!vertices) {
      vertices = this.getVertices();
    }
    if (vertices.length == 0)
      return;
    ;
    this.boundingBox.computeBounds(vertices);
    this.boundingSphere.computeBounds(vertices, this.boundingBox);
  }
  mergeSharedVertices() {
    const vArray = this.getVertices();
    const nArray = this.getNormals();
    const cArray = this.getColors();
    const uvArray = this.getTextureCoordinates();
    const vertices = [];
    const normals = [];
    const colors = [];
    const uvs = [];
    const indices = this.getIndices();
    for (let i = 0; i < vArray.length; i += 3) {
      vertices.push(new Vector3(vArray[i], vArray[i + 1], vArray[i + 2]));
      normals.push(new Vector3(nArray[i], nArray[i + 1], nArray[i + 2]));
      colors.push(new Color(cArray[i], cArray[i + 1], cArray[i + 2]));
    }
    for (let i = 0; i < uvArray.length; i += 2) {
      uvs.push(new Vector2(uvArray[i], uvArray[i + 1]));
    }
    const newVertices = [];
    const newNormals = [];
    const newColors = [];
    const newUVs = [];
    const newIndices = indices.slice();
    const counts = [];
    for (let i = 0; i < vertices.length; i++) {
      let duplicate = false;
      for (let j = 0; j < newVertices.length; j++) {
        if (vertices[i].equals(newVertices[j])) {
          for (let k = 0; k < indices.length; k++) {
            if (indices[k] == i)
              newIndices[k] = j;
          }
          newNormals[j].add(normals[i]);
          newColors[j].add(colors[i]);
          newUVs[j].add(uvs[i]);
          counts[j]++;
          duplicate = true;
        }
      }
      if (!duplicate) {
        newVertices.push(vertices[i]);
        newNormals.push(normals[i]);
        newColors.push(colors[i]);
        newUVs.push(uvs[i]);
        counts.push(1);
        for (let k = 0; k < indices.length; k++) {
          if (indices[k] == i)
            newIndices[k] = newVertices.length - 1;
        }
      }
    }
    for (let i = 0; i < newVertices.length; i++) {
      newNormals[i].multiplyScalar(1 / counts[i]);
      newColors[i].multiplyScalar(1 / counts[i]);
      newUVs[i].multiplyScalar(1 / counts[i]);
    }
    this.setVertices(newVertices);
    this.setNormals(newNormals);
    this.setColors(newColors);
    this.setTextureCoordinates(newUVs);
    this.setIndices(newIndices);
  }
};

// node_modules/gophergfx/src/geometry/3d/MeshInstance.ts
var MeshInstance = class extends Transform3 {
  constructor(baseMesh, copyTransform = true) {
    super();
    this.baseMesh = baseMesh;
    this.material = baseMesh.material;
    if (copyTransform) {
      this.position.copy(baseMesh.position);
      this.rotation.copy(baseMesh.rotation);
      this.scale.copy(baseMesh.scale);
    }
  }
  getBaseMesh() {
    return this.baseMesh;
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.material.draw(this.baseMesh, this, camera, lightManager);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
};

// node_modules/gophergfx/src/geometry/3d/BoxMesh.ts
var BoxMesh = class extends Mesh {
  constructor(width = 1, height = 1, depth = 1) {
    super();
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.createVertices(this.width, this.height, this.depth);
    this.createNormals();
    this.createTextureCoords();
    this.createIndices();
    this.createDefaultVertexColors();
  }
  setLine(startPoint, endPoint, thickness) {
    this.position.copy(startPoint);
    this.lookAt(endPoint);
    const distance = Vector3.distanceBetween(startPoint, endPoint);
    this.translateZ(-distance / 2);
    this.scale.x = thickness;
    this.scale.y = thickness;
    this.scale.z = distance;
  }
  createVertices(width, height, depth) {
    const vertices = [];
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    this.setVertices(vertices);
  }
  createNormals() {
    const normals = [];
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    this.setNormals(normals);
  }
  createIndices() {
    const indices = [];
    indices.push(0, 1, 2);
    indices.push(2, 3, 0);
    indices.push(4, 6, 5);
    indices.push(6, 4, 7);
    indices.push(8, 9, 10);
    indices.push(10, 11, 8);
    indices.push(12, 14, 13);
    indices.push(14, 12, 15);
    indices.push(16, 17, 18);
    indices.push(18, 19, 16);
    indices.push(20, 22, 21);
    indices.push(22, 20, 23);
    this.setIndices(indices);
  }
  createTextureCoords() {
    const uvs = [];
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/3d/SphereMesh.ts
var SphereMesh = class extends Mesh {
  constructor(radius = 1, subdivisions = 3) {
    super();
    this.radius = radius;
    this.subdivisions = subdivisions;
    this.createSphere(this.radius, this.subdivisions);
  }
  createSphere(radius, subdivisions) {
    let vertices = [];
    let indices = [];
    const normals = [];
    const texCoords = [];
    const phi = (1 + Math.sqrt(5)) * 0.5;
    const a = 1;
    const b = 1 / phi;
    vertices.push(new Vector3(0, b, -a));
    vertices.push(new Vector3(b, a, 0));
    vertices.push(new Vector3(-b, a, 0));
    vertices.push(new Vector3(0, b, a));
    vertices.push(new Vector3(0, -b, a));
    vertices.push(new Vector3(-a, 0, b));
    vertices.push(new Vector3(0, -b, -a));
    vertices.push(new Vector3(a, 0, -b));
    vertices.push(new Vector3(a, 0, b));
    vertices.push(new Vector3(-a, 0, -b));
    vertices.push(new Vector3(b, -a, 0));
    vertices.push(new Vector3(-b, -a, 0));
    for (let i = 0; i < vertices.length; i++) {
      vertices[i].normalize();
    }
    indices.push(2, 1, 0);
    indices.push(1, 2, 3);
    indices.push(5, 4, 3);
    indices.push(4, 8, 3);
    indices.push(7, 6, 0);
    indices.push(6, 9, 0);
    indices.push(11, 10, 4);
    indices.push(10, 11, 6);
    indices.push(9, 5, 2);
    indices.push(5, 9, 11);
    indices.push(8, 7, 1);
    indices.push(7, 8, 10);
    indices.push(2, 5, 3);
    indices.push(8, 1, 3);
    indices.push(9, 2, 0);
    indices.push(1, 7, 0);
    indices.push(11, 9, 6);
    indices.push(7, 10, 6);
    indices.push(5, 11, 4);
    indices.push(10, 8, 4);
    for (let div = 0; div < subdivisions; div++) {
      const newIndices = [];
      for (let i = 0; i < indices.length / 3; i++) {
        const index = i * 3;
        const centroids = this.createCentroids(vertices, indices[index], indices[index + 1], indices[index + 2]);
        vertices.push(...centroids);
        const triangles = this.subdivide(
          indices[index],
          indices[index + 1],
          indices[index + 2],
          vertices.length - 3,
          vertices.length - 2,
          vertices.length - 1
        );
        newIndices.push(...triangles);
      }
      indices = newIndices;
    }
    for (let i = 0; i < vertices.length; i++) {
      vertices[i].multiplyScalar(radius);
    }
    [vertices, indices] = this.mergeSphereVertices(vertices, indices);
    for (let i = 0; i < vertices.length; i++) {
      normals.push(Vector3.normalize(vertices[i]));
      const v = 1 - (vertices[i].y + radius) / (2 * radius);
      const direction = new Vector3(vertices[i].x, 0, vertices[i].z);
      direction.normalize();
      let angle = Math.acos(Vector3.FORWARD.dot(direction));
      if (direction.x > 0)
        angle = Math.PI * 2 - angle;
      const u = angle / (Math.PI * 2);
      texCoords.push(u, v);
    }
    const indicesLength = indices.length;
    for (let i = 0; i < indicesLength; i += 3) {
      if (this.isSeamVertex(i, vertices, indices)) {
        if (this.isEndVertex(i + 1, vertices, indices) && this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          indices[i] = vertices.length - 1;
        } else if (this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 1] = vertices.length - 1;
        }
      } else if (this.isSeamVertex(i + 1, vertices, indices)) {
        if (this.isEndVertex(i, vertices, indices) && this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i + 1] = vertices.length - 1;
        } else if (this.isEndVertex(i, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 1] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 1] = vertices.length - 1;
        }
      } else if (this.isSeamVertex(i + 2, vertices, indices)) {
        if (this.isEndVertex(i, vertices, indices) && this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 1] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        }
      }
    }
    this.setVertices(vertices);
    this.setNormals(normals);
    this.setTextureCoordinates(texCoords);
    this.setIndices(indices);
    this.createDefaultVertexColors();
  }
  isEndVertex(i, vertices, indices) {
    if (vertices[indices[i]].x > 0)
      return true;
    else
      return false;
  }
  isSeamVertex(i, vertices, indices) {
    if (vertices[indices[i]].x == 0 && vertices[indices[i]].z <= 0)
      return true;
    else
      return false;
  }
  createCentroids(vertices, v1, v2, v3) {
    const centroids = [];
    const centroid1 = Vector3.add(vertices[v1], vertices[v2]);
    centroid1.divideScalar(2);
    centroid1.normalize();
    centroids.push(centroid1);
    const centroid2 = Vector3.add(vertices[v2], vertices[v3]);
    centroid2.divideScalar(2);
    centroid2.normalize();
    centroids.push(centroid2);
    const centroid3 = Vector3.add(vertices[v3], vertices[v1]);
    centroid3.divideScalar(2);
    centroid3.normalize();
    centroids.push(centroid3);
    return centroids;
  }
  subdivide(v1, v2, v3, c1, c2, c3) {
    const triangles = [];
    triangles.push(v1, c1, c3);
    triangles.push(v2, c2, c1);
    triangles.push(v3, c3, c2);
    triangles.push(c1, c2, c3);
    return triangles;
  }
  mergeSphereVertices(vertices, indices) {
    const newVertices = [];
    const newIndices = [];
    indices.forEach((elem) => {
      newIndices.push(elem);
    });
    for (let i = 0; i < vertices.length; i++) {
      let duplicate = false;
      for (let j = 0; j < newVertices.length; j++) {
        if (vertices[i].equals(newVertices[j])) {
          for (let k = 0; k < indices.length; k++) {
            if (indices[k] == i)
              newIndices[k] = j;
          }
          duplicate = true;
        }
      }
      if (!duplicate) {
        newVertices.push(vertices[i]);
        for (let k = 0; k < indices.length; k++) {
          if (indices[k] == i)
            newIndices[k] = newVertices.length - 1;
        }
      }
    }
    return [newVertices, newIndices];
  }
};

// node_modules/gophergfx/src/geometry/3d/ConeMesh.ts
var ConeMesh = class extends Mesh {
  constructor(radius = 1, height = 1, numSegments = 8) {
    super();
    this.radius = radius;
    this.height = height;
    this.createVertices(this.radius, this.height, numSegments);
    this.createNormals(numSegments);
    this.createTextureCoords(numSegments);
    this.createIndices(numSegments);
    this.createDefaultVertexColors();
  }
  createVertices(radius, height, numSegments) {
    const vertices = [];
    const angle = Math.PI * 2 / numSegments;
    vertices.push(0, height / 2, 0);
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, -height / 2, Math.sin(angle * i) * radius);
    }
    vertices.push(0, -height / 2, 0);
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, -height / 2, Math.sin(angle * i) * radius);
    }
    this.setVertices(vertices);
  }
  createNormals(numSegments) {
    const normals = [];
    const angle = Math.PI * 2 / numSegments;
    normals.push(0, 1, 0);
    for (let i = 0; i <= numSegments; i++) {
      normals.push(Math.cos(angle * i), 0, Math.sin(angle * i));
    }
    normals.push(0, -1, 0);
    for (let i = 0; i <= numSegments; i++) {
      normals.push(0, -1, 0);
    }
    this.setNormals(normals);
  }
  createIndices(numSegments) {
    const indices = [];
    for (let i = 0; i < numSegments; i++) {
      indices.push(0, i + 2, i + 1);
    }
    const startIndex = numSegments + 2;
    for (let i = 0; i < numSegments; i++) {
      indices.push(startIndex, startIndex + i + 1, startIndex + i + 2);
    }
    this.setIndices(indices);
  }
  createTextureCoords(numSegments) {
    const uvs = [];
    uvs.push(0.5, 0);
    for (let i = 0; i <= numSegments; i++) {
      uvs.push(i / numSegments, 1);
    }
    uvs.push(0.5, 0.5);
    const angle = Math.PI * 2 / numSegments;
    for (let i = 0; i <= numSegments; i++) {
      uvs.push((Math.cos(angle * i) + 1) / 2, (Math.sin(angle * i) - 1) / -2);
    }
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/3d/PlaneMesh.ts
var PlaneMesh = class extends Mesh {
  constructor(width = 1, height = 1) {
    super();
    this.width = width;
    this.height = height;
    this.createVertices(this.width, this.height);
    this.createNormals();
    this.createTextureCoords();
    this.createIndices();
    this.createDefaultVertexColors();
  }
  createVertices(width, height) {
    const vertices = [];
    vertices.push(-width / 2, -height / 2, 0);
    vertices.push(width / 2, -height / 2, 0);
    vertices.push(width / 2, height / 2, 0);
    vertices.push(-width / 2, height / 2, 0);
    this.setVertices(vertices);
  }
  createNormals() {
    const normals = [];
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    this.setNormals(normals);
  }
  createIndices() {
    const indices = [];
    indices.push(0, 2, 1);
    indices.push(2, 0, 3);
    this.setIndices(indices);
  }
  createTextureCoords() {
    const uvs = [];
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/3d/CylinderMesh.ts
var CylinderMesh = class extends Mesh {
  constructor(numSegments = 20, radius = 1, height = 1) {
    super();
    this.numSegments = numSegments;
    this.radius = radius;
    this.height = height;
    this.createCylinderMesh(numSegments, height);
  }
  createCylinderMesh(numSegments, height) {
    const vertices = [];
    const normals = [];
    const indices = [];
    const uvs = [];
    const angleIncrement = Math.PI * 2 / numSegments;
    const numVerticesX = numSegments + 1;
    for (let i = 0; i < numVerticesX; i++) {
      const angle = i * angleIncrement;
      vertices.push(Math.cos(angle) * this.radius, height / 2, Math.sin(angle) * this.radius);
      vertices.push(Math.cos(angle) * this.radius, -height / 2, Math.sin(angle) * this.radius);
      normals.push(Math.cos(angle), 0, Math.sin(angle));
      normals.push(Math.cos(angle), 0, Math.sin(angle));
      uvs.push(1 - i / numSegments, 0);
      uvs.push(1 - i / numSegments, 1);
    }
    for (let i = 0; i < numSegments; i++) {
      const angle = i * angleIncrement;
      indices.push(i * 2, i * 2 + 2, i * 2 + 1);
      indices.push(i * 2 + 1, i * 2 + 2, i * 2 + 3);
    }
    const topCenterIndex = vertices.length / 3;
    vertices.push(0, height / 2, 0);
    normals.push(0, 1, 0);
    uvs.push(0.5, 0);
    for (let i = 0; i < numVerticesX; i++) {
      const angle = i * angleIncrement;
      vertices.push(Math.cos(angle) * this.radius, height / 2, Math.sin(angle) * this.radius);
      normals.push(0, 1, 0);
      uvs.push(1 - i / numSegments, 0);
    }
    for (let i = 0; i < numSegments; i++) {
      indices.push(topCenterIndex, topCenterIndex + i + 2, topCenterIndex + i + 1);
    }
    const bottomCenterIndex = vertices.length / 3;
    vertices.push(0, -height / 2, 0);
    normals.push(0, -1, 0);
    uvs.push(0.5, 1);
    for (let i = 0; i < numVerticesX; i++) {
      const angle = i * angleIncrement;
      vertices.push(Math.cos(angle) * this.radius, -height / 2, Math.sin(angle) * this.radius);
      normals.push(0, -1, 0);
      uvs.push(1 - i / numSegments, 1);
    }
    for (let i = 0; i < numSegments; i++) {
      indices.push(bottomCenterIndex, bottomCenterIndex + i + 1, bottomCenterIndex + i + 2);
    }
    this.setVertices(vertices);
    this.setNormals(normals);
    this.setIndices(indices);
    this.setTextureCoordinates(uvs);
    this.createDefaultVertexColors();
  }
};

// node_modules/gophergfx/src/shaders/unlit.vert
var unlit_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    vertColor = color;\n    uv = texCoord.xy;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n}";

// node_modules/gophergfx/src/shaders/unlit.frag
var unlit_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 materialColor;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec2 uv;\n\nin vec4 vertColor;\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = materialColor * vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/UnlitMaterial.ts
var _UnlitMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.color = new Color(1, 1, 1);
    _UnlitMaterial.shader.initialize(this.gl);
    this.colorUniform = _UnlitMaterial.shader.getUniform(this.gl, "materialColor");
    this.textureUniform = _UnlitMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _UnlitMaterial.shader.getUniform(this.gl, "useTexture");
    this.modelViewUniform = _UnlitMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = _UnlitMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.positionAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "position");
    this.colorAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_UnlitMaterial.shader.getProgram());
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(transform.worldMatrix, camera.viewMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.color.copy(color);
  }
};
var UnlitMaterial = _UnlitMaterial;
UnlitMaterial.shader = new ShaderProgram(unlit_default, unlit_default2);

// node_modules/gophergfx/src/shaders/shape.vert
var shape_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat3 modelMatrix;\nuniform float layer;\n\nin vec2 position;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    vertColor = color;\n    uv = texCoord.xy; \n    vec3 worldPosition = modelMatrix * vec3(position, 1);\n    gl_Position = vec4(worldPosition.x, worldPosition.y, layer, 1);\n}";

// node_modules/gophergfx/src/shaders/shape.frag
var shape_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 materialColor;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = materialColor * vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/Material2.ts
var _Material2 = class {
  constructor() {
    this.gl = GfxApp.getInstance().renderer.gl;
    this.visible = true;
    this.color = new Color(1, 1, 1);
    this.drawMode = this.gl.LINE_LOOP;
    this.texture = null;
    _Material2.shader.initialize(this.gl);
    this.colorUniform = _Material2.shader.getUniform(this.gl, "materialColor");
    this.modelUniform = _Material2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform = _Material2.shader.getUniform(this.gl, "layer");
    this.textureUniform = _Material2.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _Material2.shader.getUniform(this.gl, "useTexture");
    this.positionAttribute = _Material2.shader.getAttribute(this.gl, "position");
    this.colorAttribute = _Material2.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _Material2.shader.getAttribute(this.gl, "texCoord");
  }
  copy(mat) {
    this.visible = mat.visible;
    this.color.copy(mat.color);
    this.drawMode = mat.drawMode;
    this.texture = mat.texture;
  }
  draw(shape, transform) {
    if (!this.visible || shape.vertexCount == 0)
      return;
    this.gl.useProgram(_Material2.shader.getProgram());
    this.gl.uniformMatrix3fv(this.modelUniform, false, transform.worldMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.uniform1f(this.layerUniform, transform.layer);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shape.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shape.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shape.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.drawArrays(this.drawMode, 0, shape.vertexCount);
  }
};
var Material2 = _Material2;
Material2.shader = new ShaderProgram(shape_default, shape_default2);

// node_modules/gophergfx/src/materials/LineMaterial.ts
var LineMaterial = class {
  constructor() {
    this.visible = true;
    this.color = new Color(1, 1, 1);
    this.gl = GfxApp.getInstance().renderer.gl;
    UnlitMaterial.shader.initialize(this.gl);
    this.colorUniform3d = UnlitMaterial.shader.getUniform(this.gl, "materialColor");
    this.modelViewUniform3d = UnlitMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform3d = UnlitMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.useTextureUniform3d = UnlitMaterial.shader.getUniform(this.gl, "useTexture");
    this.textureUniform3d = UnlitMaterial.shader.getUniform(this.gl, "textureImage");
    this.positionAttribute3d = UnlitMaterial.shader.getAttribute(this.gl, "position");
    this.colorAttribute3d = UnlitMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute3d = UnlitMaterial.shader.getAttribute(this.gl, "texCoord");
    Material2.shader.initialize(this.gl);
    this.colorUniform2d = Material2.shader.getUniform(this.gl, "materialColor");
    this.modelUniform2d = Material2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform2d = Material2.shader.getUniform(this.gl, "layer");
    this.useTextureUniform2d = Material2.shader.getUniform(this.gl, "useTexture");
    this.textureUniform2d = Material2.shader.getUniform(this.gl, "textureImage");
    this.positionAttribute2d = Material2.shader.getAttribute(this.gl, "position");
    this.colorAttribute2d = Material2.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute2d = Material2.shader.getAttribute(this.gl, "texCoord");
  }
  draw3d(line, camera) {
    if (!this.visible || line.vertexCount < 2)
      return;
    this.gl.useProgram(UnlitMaterial.shader.getProgram());
    this.gl.uniform1i(this.useTextureUniform3d, 0);
    this.gl.disableVertexAttribArray(this.texCoordAttribute3d);
    this.gl.uniformMatrix4fv(this.modelViewUniform3d, false, Matrix4.multiply(line.worldMatrix, camera.viewMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform3d, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform3d, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.enableVertexAttribArray(this.colorAttribute3d);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, line.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute3d, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.positionAttribute3d);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, line.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute3d, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.drawArrays(line.glLineMode(), 0, line.vertexCount);
  }
  draw2d(line) {
    if (!this.visible || line.vertexCount < 2)
      return;
    this.gl.useProgram(Material2.shader.getProgram());
    this.gl.uniform1i(this.useTextureUniform2d, 0);
    this.gl.disableVertexAttribArray(this.texCoordAttribute2d);
    this.gl.uniformMatrix3fv(this.modelUniform2d, false, line.worldMatrix.mat);
    this.gl.uniform4f(this.colorUniform2d, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.uniform1f(this.layerUniform2d, line.layer);
    this.gl.enableVertexAttribArray(this.colorAttribute2d);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, line.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute2d, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.positionAttribute2d);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, line.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute2d, 2, this.gl.FLOAT, false, 0, 0);
    this.gl.drawArrays(line.glLineMode(), 0, line.vertexCount);
  }
};

// node_modules/gophergfx/src/geometry/3d/Line3.ts
var LineMode3 = /* @__PURE__ */ ((LineMode32) => {
  LineMode32[LineMode32["LINES"] = 0] = "LINES";
  LineMode32[LineMode32["LINE_STRIP"] = 1] = "LINE_STRIP";
  LineMode32[LineMode32["LINE_LOOP"] = 2] = "LINE_LOOP";
  return LineMode32;
})(LineMode3 || {});
var Line3 = class extends Transform3 {
  constructor(lineMode = 1 /* LINE_STRIP */) {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.vertexCount = 0;
    this.material = new LineMaterial();
    this.lineMode = lineMode;
  }
  createFromBox(box) {
    const vertices = [];
    vertices.push(box.max.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.max.z);
    vertices.push(box.min.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.min.z);
    vertices.push(box.max.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.max.z);
    vertices.push(box.min.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.min.z);
    vertices.push(box.max.x, box.min.y, box.max.z);
    vertices.push(box.max.x, box.max.y, box.max.z);
    vertices.push(box.max.x, box.min.y, box.min.z);
    vertices.push(box.max.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.min.z);
    vertices.push(box.min.x, box.max.y, box.min.z);
    vertices.push(box.min.x, box.min.y, box.max.z);
    vertices.push(box.min.x, box.max.y, box.max.z);
    this.setVertices(vertices);
    this.createDefaultVertexColors();
    this.lineMode = 0 /* LINES */;
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.material.draw3d(this, camera);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 3;
      this.boundingBox.computeBounds(vArray);
      this.boundingSphere.computeBounds(vArray, this.boundingBox);
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  glLineMode() {
    if (this.lineMode == 0 /* LINES */)
      return this.gl.LINES;
    else if (this.lineMode == 1 /* LINE_STRIP */)
      return this.gl.LINE_STRIP;
    else
      return this.gl.LINE_LOOP;
  }
};

// node_modules/gophergfx/src/geometry/3d/Axes3.ts
var Axes3 = class extends Line3 {
  constructor(size = 1) {
    super(0 /* LINES */);
    const vertices = [];
    const colors = [];
    vertices.push(0, 0, 0);
    vertices.push(size, 0, 0);
    colors.push(1, 0, 0, 1);
    colors.push(1, 0, 0, 1);
    vertices.push(0, 0, 0);
    vertices.push(0, size, 0);
    colors.push(0, 1, 0, 1);
    colors.push(0, 1, 0, 1);
    vertices.push(0, 0, 0);
    vertices.push(0, 0, size);
    colors.push(0, 0, 1, 1);
    colors.push(0, 0, 1, 1);
    this.setVertices(vertices);
    this.setColors(colors);
  }
};

// node_modules/gophergfx/src/geometry/2d/Shape.ts
var Shape = class extends Transform2 {
  constructor() {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.texCoordBuffer = this.gl.createBuffer();
    this.customBuffers = [];
    this.vertexCount = 0;
    this.material = new Material2();
  }
  draw() {
    if (!this.visible)
      return;
    this.material.draw(this, this);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 2;
      this.computeBounds(vertices);
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
    }
  }
  setTextureCoordinates(texCoords, usage = this.gl.STATIC_DRAW) {
    if (texCoords.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      if (typeof texCoords[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), usage);
      } else {
        const tArray = [];
        texCoords.forEach((elem) => {
          tArray.push(elem.x, elem.y);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), usage);
      }
    }
  }
  setCustomBuffer(bufferIndex, values, usage = this.gl.STATIC_DRAW) {
    while (this.customBuffers.length <= bufferIndex)
      this.customBuffers.push(this.gl.createBuffer());
    if (values.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.customBuffers[bufferIndex]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), usage);
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  getTextureCoordinates() {
    const texCoordArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, texCoordArray);
    return [...texCoordArray];
  }
  getCustomBuffer(bufferIndex, numValues) {
    const customBufferArray = new Float32Array(this.vertexCount * numValues);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.customBuffers[bufferIndex]);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, customBufferArray);
    return [...customBufferArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  computeBounds(vertices) {
    if (!vertices) {
      vertices = this.getVertices();
    }
    if (vertices.length == 0)
      return;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      this.boundingBox.max.set(vArray[0], vArray[1]);
      this.boundingBox.min.set(vArray[0], vArray[1]);
      for (let i = 0; i < vArray.length; i += 3) {
        if (vArray[i] > this.boundingBox.max.x)
          this.boundingBox.max.x = vArray[i];
        if (vArray[i] < this.boundingBox.min.x)
          this.boundingBox.min.x = vArray[i];
        if (vArray[i + 1] > this.boundingBox.max.y)
          this.boundingBox.max.y = vArray[i + 1];
        if (vArray[i + 1] < this.boundingBox.min.y)
          this.boundingBox.min.y = vArray[i + 1];
      }
    } else {
      this.boundingBox.max.copy(vertices[0]);
      this.boundingBox.min.copy(vertices[0]);
      vertices.forEach((elem) => {
        if (elem.x > this.boundingBox.max.x)
          this.boundingBox.max.x = elem.x;
        if (elem.x < this.boundingBox.min.x)
          this.boundingBox.min.x = elem.x;
        if (elem.y > this.boundingBox.max.y)
          this.boundingBox.max.y = elem.y;
        if (elem.y < this.boundingBox.min.y)
          this.boundingBox.min.y = elem.y;
      });
    }
    this.boundingCircle.center.copy(this.boundingBox.min);
    this.boundingCircle.center.add(this.boundingBox.max);
    this.boundingCircle.center.multiplyScalar(0.5);
    this.boundingCircle.radius = 0;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      for (let i = 0; i < vArray.length; i += 3) {
        const distance = Math.sqrt(
          (vArray[i] - this.boundingCircle.center.x) * (vArray[i] - this.boundingCircle.center.x) + (vArray[i + 1] - this.boundingCircle.center.y) * (vArray[i + 1] - this.boundingCircle.center.y)
        );
        if (distance > this.boundingCircle.radius)
          this.boundingCircle.radius = distance;
      }
    } else {
      vertices.forEach((elem) => {
        const distance = elem.distanceTo(this.boundingCircle.center);
        if (distance > this.boundingCircle.radius)
          this.boundingCircle.radius = distance;
      });
    }
  }
};

// node_modules/gophergfx/src/geometry/2d/ShapeInstance.ts
var ShapeInstance = class extends Transform2 {
  constructor(baseShape, copyTransform = true) {
    super();
    this.baseShape = baseShape;
    this.boundingBox = baseShape.boundingBox;
    this.boundingCircle = baseShape.boundingCircle;
    this.material = baseShape.material;
    if (copyTransform) {
      this.position.copy(baseShape.position);
      this.rotation = baseShape.rotation;
      this.scale.copy(baseShape.scale);
      this.layer = baseShape.layer;
    }
  }
  getBaseShape() {
    return this.baseShape;
  }
  draw() {
    if (!this.visible)
      return;
    this.material.draw(this.baseShape, this);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
};

// node_modules/gophergfx/src/geometry/2d/Rectangle.ts
var Rectangle = class extends Shape {
  constructor(width = 1, height = 1) {
    super();
    this.width = width;
    this.height = height;
    this.material.drawMode = this.gl.TRIANGLE_STRIP;
    this.createVertices(this.width, this.height);
    this.createTextureCoordinates();
    this.createDefaultVertexColors();
  }
  createVertices(width, height) {
    const vertices = [];
    vertices.push(-width / 2, height / 2);
    vertices.push(-width / 2, -height / 2);
    vertices.push(width / 2, height / 2);
    vertices.push(width / 2, -height / 2);
    this.setVertices(vertices);
  }
  createTextureCoordinates() {
    const uvs = [];
    uvs.push(0, 0);
    uvs.push(0, 1);
    uvs.push(1, 0);
    uvs.push(1, 1);
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/2d/Circle.ts
var Circle = class extends Shape {
  constructor(radius = 0.5, numSegments = 50) {
    super();
    this.radius = radius;
    this.material.drawMode = this.gl.TRIANGLE_FAN;
    this.createVertices(this.radius, numSegments);
    this.createTextureCoordinates(numSegments);
    this.createDefaultVertexColors();
  }
  createVertices(radius, numSegments) {
    const vertices = [0, 0];
    const angle = Math.PI * 2 / numSegments;
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, Math.sin(angle * i) * radius);
    }
    this.setVertices(vertices);
  }
  createTextureCoordinates(numSegments) {
    const uvs = [0.5, 0.5];
    const angle = Math.PI * 2 / numSegments;
    for (let i = 0; i <= numSegments; i++) {
      uvs.push((Math.cos(angle * i) + 1) / 2, (Math.sin(angle * i) - 1) / -2);
    }
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/2d/Line2.ts
var LineMode2 = /* @__PURE__ */ ((LineMode22) => {
  LineMode22[LineMode22["LINES"] = 0] = "LINES";
  LineMode22[LineMode22["LINE_STRIP"] = 1] = "LINE_STRIP";
  LineMode22[LineMode22["LINE_LOOP"] = 2] = "LINE_LOOP";
  return LineMode22;
})(LineMode2 || {});
var Line2 = class extends Transform2 {
  constructor(lineMode = 1 /* LINE_STRIP */) {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.vertexCount = 0;
    this.material = new LineMaterial();
    this.lineMode = lineMode;
  }
  createFromBox(box) {
    const vertices = [];
    vertices.push(box.min.x, box.min.y);
    vertices.push(box.max.x, box.min.y);
    vertices.push(box.max.x, box.max.y);
    vertices.push(box.min.x, box.max.y);
    this.setVertices(vertices);
    this.createDefaultVertexColors();
    this.lineMode = 2 /* LINE_LOOP */;
  }
  draw() {
    if (!this.visible)
      return;
    this.material.draw2d(this);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 2;
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.ARRAY_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  glLineMode() {
    if (this.lineMode == 0 /* LINES */)
      return this.gl.LINES;
    else if (this.lineMode == 1 /* LINE_STRIP */)
      return this.gl.LINE_STRIP;
    else
      return this.gl.LINE_LOOP;
  }
};

// node_modules/gophergfx/src/geometry/2d/Axes2.ts
var Axes2 = class extends Line2 {
  constructor(size = 1) {
    super(0 /* LINES */);
    const vertices = [];
    const colors = [];
    vertices.push(0, 0);
    vertices.push(size, 0);
    colors.push(1, 0, 0, 1);
    colors.push(1, 0, 0, 1);
    vertices.push(0, 0);
    vertices.push(0, size);
    colors.push(0, 1, 0, 1);
    colors.push(0, 1, 0, 1);
    this.setVertices(vertices);
    this.setColors(colors);
  }
};

// node_modules/gophergfx/src/shaders/particles2.vert
var particles2_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat3 modelMatrix;\nuniform float layer;\n\nin vec2 particlePosition;\nin float particleSize;\n\nin vec2 vertPosition;\nin vec4 vertColor;\nin vec2 texCoord;\n\nout vec4 color;\nout vec2 uv;\n\nvoid main() \n{\n    color = vertColor;\n    uv = texCoord.xy; \n    vec3 worldPosition = modelMatrix * vec3(particlePosition + (vertPosition * particleSize), 1);\n    gl_Position = vec4(worldPosition.x, worldPosition.y, layer, 1);\n}";

// node_modules/gophergfx/src/shaders/particles2.frag
var particles2_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 materialColor;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 color;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = materialColor * color;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/geometry/2d/Particles2.ts
var _Particles2 = class extends Transform2 {
  constructor(baseParticle, numParticles) {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.baseParticle = baseParticle;
    this.numParticles = numParticles;
    this.particlePositions = [];
    this.particleSizes = [];
    for (let i = 0; i < this.numParticles; i++) {
      this.particlePositions.push(new Vector2());
      this.particleSizes.push(1);
    }
    this.particlePositionBuffer = this.gl.createBuffer();
    this.particleSizeBuffer = this.gl.createBuffer();
    _Particles2.shader.initialize(this.gl);
    this.colorUniform = _Particles2.shader.getUniform(this.gl, "materialColor");
    this.modelUniform = _Particles2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform = _Particles2.shader.getUniform(this.gl, "layer");
    this.textureUniform = _Particles2.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _Particles2.shader.getUniform(this.gl, "useTexture");
    this.particlePositionAttribute = _Particles2.shader.getAttribute(this.gl, "particlePosition");
    this.particleSizeAttribute = _Particles2.shader.getAttribute(this.gl, "particleSize");
    this.vertPositionAttribute = _Particles2.shader.getAttribute(this.gl, "vertPosition");
    this.vertColorAttribute = _Particles2.shader.getAttribute(this.gl, "vertColor");
    this.texCoordAttribute = _Particles2.shader.getAttribute(this.gl, "texCoord");
    const particlePositionArray = [];
    for (let i = 0; i < this.particlePositions.length; i++)
      particlePositionArray.push(this.particlePositions[i].x, this.particlePositions[i].y);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(particlePositionArray), this.gl.DYNAMIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.particleSizes), this.gl.DYNAMIC_DRAW);
  }
  getBaseParticle() {
    return this.baseParticle;
  }
  update(updatePositions = true, updateSizes = false) {
    if (updatePositions) {
      const particlePositionArray = [];
      for (let i = 0; i < this.particlePositions.length; i++)
        particlePositionArray.push(this.particlePositions[i].x, this.particlePositions[i].y);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
      this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(particlePositionArray));
    }
    if (updateSizes) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);
      this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(this.particleSizes));
    }
  }
  draw() {
    if (!this.visible)
      return;
    this.gl.useProgram(_Particles2.shader.getProgram());
    this.gl.uniformMatrix3fv(this.modelUniform, false, this.worldMatrix.mat);
    this.gl.uniform4f(
      this.colorUniform,
      this.baseParticle.material.color.r,
      this.baseParticle.material.color.g,
      this.baseParticle.material.color.b,
      this.baseParticle.material.color.a
    );
    this.gl.uniform1f(this.layerUniform, this.layer);
    this.gl.enableVertexAttribArray(this.particlePositionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particlePositionBuffer);
    this.gl.vertexAttribPointer(this.particlePositionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    this.gl.vertexAttribDivisor(this.particlePositionAttribute, 1);
    this.gl.enableVertexAttribArray(this.particleSizeAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.particleSizeBuffer);
    this.gl.vertexAttribPointer(this.particleSizeAttribute, 1, this.gl.FLOAT, false, 0, 0);
    this.gl.vertexAttribDivisor(this.particleSizeAttribute, 1);
    this.gl.enableVertexAttribArray(this.vertColorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.colorBuffer);
    this.gl.vertexAttribPointer(this.vertColorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.vertPositionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.positionBuffer);
    this.gl.vertexAttribPointer(this.vertPositionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    if (this.baseParticle.material.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.baseParticle.material.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.baseParticle.material.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.baseParticle.material.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.baseParticle.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.drawArraysInstanced(this.baseParticle.material.drawMode, 0, this.baseParticle.vertexCount, this.numParticles);
    this.gl.vertexAttribDivisor(this.particlePositionAttribute, 0);
    this.gl.vertexAttribDivisor(this.particleSizeAttribute, 0);
    this.children.forEach((elem) => {
      elem.draw();
    });
  }
};
var Particles2 = _Particles2;
Particles2.shader = new ShaderProgram(particles2_default, particles2_default2);

// node_modules/gophergfx/src/interaction/OrbitControls.ts
var OrbitControls = class {
  constructor(camera, distance = 1, zoomable = true) {
    this.camera = camera;
    this.zoomable = zoomable;
    this.distance = distance;
    this.rotationSpeedX = Math.PI / 4;
    this.rotationSpeedY = Math.PI / 4;
    this.zoomSpeed = 0.25;
    this.mouseButton = 0;
    this.targetPoint = new Vector3();
    this.cameraOrbitX = new Quaternion();
    this.cameraOrbitY = new Quaternion();
    this.rotationDirection = new Vector3();
    this.zoomDirection = 0;
    this.mouseDrag = false;
    this.mouseMovement = new Vector2();
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("wheel", (event) => {
      this.onMouseWheel(event);
    });
    this.updateCamera();
  }
  setTargetPoint(targetPoint) {
    this.targetPoint.copy(targetPoint);
    this.updateCamera();
  }
  setDistance(distance) {
    this.distance = distance;
    this.updateCamera();
  }
  setOrbit(orbitX, orbitY) {
    this.cameraOrbitX.setRotationX(orbitX);
    this.cameraOrbitY.setRotationY(orbitY);
    this.updateCamera();
  }
  onMouseDown(event) {
    if (this.mouseButton == event.button && event.target.localName == "canvas")
      this.mouseDrag = true;
  }
  onMouseUp(event) {
    if (this.mouseButton == event.button)
      this.mouseDrag = false;
  }
  onMouseMove(event) {
    if (this.mouseDrag) {
      this.mouseMovement.x = -event.movementY;
      this.mouseMovement.y = -event.movementX;
    }
  }
  onMouseWheel(event) {
    if (this.zoomable) {
      this.zoomDirection += event.deltaY;
    }
  }
  update(deltaTime) {
    this.rotationDirection.x += this.mouseMovement.x;
    this.rotationDirection.y += this.mouseMovement.y;
    this.mouseMovement.x = 0;
    this.mouseMovement.y = 0;
    this.cameraOrbitX.multiply(Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeedX * deltaTime));
    this.cameraOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeedY * deltaTime));
    this.distance += this.zoomDirection * this.zoomSpeed * deltaTime;
    this.rotationDirection.set(0, 0, 0);
    this.zoomDirection = 0;
    this.updateCamera();
  }
  updateCamera() {
    this.camera.rotation.copy(this.cameraOrbitY);
    this.camera.rotation.multiply(this.cameraOrbitX);
    this.camera.position.set(0, 0, this.distance);
    this.camera.position.rotate(this.camera.rotation);
    this.camera.position.add(this.targetPoint);
  }
  freeze() {
    this.mouseDrag = false;
    this.mouseMovement.set(0, 0);
    this.zoomDirection = 0;
  }
};

// node_modules/gophergfx/src/interaction/FirstPersonControls.ts
var FirstPersonControls = class {
  constructor(camera) {
    this.camera = camera;
    this.mouseButton = 0;
    this.translationSpeed = 2;
    this.rotationSpeed = Math.PI / 4;
    this.flyMode = true;
    this.hasMoved = false;
    this.moveDirection = new Vector3();
    this.rotationDirection = new Vector3();
    this.mouseDrag = false;
    this.mouseMovement = new Vector2();
    this.targetOrbitX = new Quaternion();
    this.targetOrbitY = new Quaternion();
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("keydown", (event) => {
      this.onKeyDown(event);
    });
    window.addEventListener("keyup", (event) => {
      this.onKeyUp(event);
    });
  }
  onMouseDown(event) {
    if (this.mouseButton == event.button && event.target.localName == "canvas")
      this.mouseDrag = true;
  }
  onMouseUp(event) {
    if (this.mouseButton == event.button)
      this.mouseDrag = false;
  }
  onMouseMove(event) {
    if (this.mouseDrag) {
      this.mouseMovement.x = -event.movementY;
      this.mouseMovement.y = -event.movementX;
    }
  }
  onKeyDown(event) {
    if (event.key == "w") {
      this.moveDirection.z = -1;
    } else if (event.key == "s") {
      this.moveDirection.z = 1;
    } else if (event.key == "a") {
      this.moveDirection.x = -1;
    } else if (event.key == "d") {
      this.moveDirection.x = 1;
    }
  }
  onKeyUp(event) {
    if (event.key == "w" && this.moveDirection.z == -1) {
      this.moveDirection.z = 0;
    }
    if (event.key == "s" && this.moveDirection.z == 1) {
      this.moveDirection.z = 0;
    } else if (event.key == "a" && this.moveDirection.x == -1) {
      this.moveDirection.x = 0;
    } else if (event.key == "d" && this.moveDirection.x == 1) {
      this.moveDirection.x = 0;
    }
  }
  update(deltaTime) {
    this.rotationDirection.x += this.mouseMovement.x;
    this.rotationDirection.y += this.mouseMovement.y;
    this.mouseMovement.x = 0;
    this.mouseMovement.y = 0;
    const newTargetOrbitX = Quaternion.multiply(this.targetOrbitX, Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeed * deltaTime));
    const testVector = new Vector3(0, 0, -1);
    testVector.rotate(newTargetOrbitX);
    if (testVector.z < 0)
      this.targetOrbitX.copy(newTargetOrbitX);
    this.targetOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeed * deltaTime));
    this.rotationDirection.set(0, 0, 0);
    const target = new Vector3(0, 0, -1);
    target.rotate(this.targetOrbitX);
    target.rotate(this.targetOrbitY);
    target.add(this.camera.position);
    this.camera.lookAt(target, Vector3.UP);
    if (this.moveDirection.length() == 0) {
      this.hasMoved = false;
    } else {
      const moveDirectionNormalized = Vector3.normalize(this.moveDirection);
      if (this.flyMode) {
        moveDirectionNormalized.multiplyScalar(this.translationSpeed * deltaTime);
        this.camera.translate(moveDirectionNormalized);
      } else {
        const translation = Vector3.rotate(moveDirectionNormalized, this.camera.rotation);
        translation.y = 0;
        translation.normalize();
        translation.multiplyScalar(this.translationSpeed * deltaTime);
        this.camera.position.add(translation);
      }
      this.hasMoved = true;
    }
  }
  freeze() {
    this.mouseDrag = false;
    this.mouseMovement.x = 0;
    this.mouseMovement.y = 0;
    this.moveDirection.set(0, 0, 0);
  }
};

// node_modules/gophergfx/src/math/Plane.ts
var Plane = class {
  constructor(point = new Vector3(), normal = new Vector3(0, 0, -1)) {
    this.point = point.clone();
    this.normal = Vector3.normalize(normal);
  }
  distanceTo(point) {
    return this.normal.dot(point) - this.point.dot(this.normal);
  }
  project(point) {
    const target = new Vector3(this.normal.x, this.normal.y, this.normal.z);
    target.multiplyScalar(-this.distanceTo(point));
    target.add(point);
    return target;
  }
};

// node_modules/gophergfx/src/math/Ray.ts
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin = origin;
    this.direction = direction;
  }
  setPickRay(deviceCoords, camera) {
    const [worldPosition, worldRotation, worldScale] = camera.worldMatrix.decompose();
    this.origin.copy(worldPosition);
    this.direction.set(deviceCoords.x, deviceCoords.y, -1);
    this.direction.transform(camera.projectionMatrix.inverse());
    this.direction.rotate(worldRotation);
    this.direction.normalize();
  }
  intersectsPlane(plane) {
    const denominator = this.direction.dot(plane.normal);
    if (Math.abs(denominator) > 1e-6) {
      const rayOriginToPlanePoint = Vector3.subtract(plane.point, this.origin);
      const t = rayOriginToPlanePoint.dot(plane.normal) / denominator;
      if (t > 0) {
        const intersectionPoint = Vector3.multiplyScalar(this.direction, t);
        intersectionPoint.add(this.origin);
        return intersectionPoint;
      }
    }
    return null;
  }
  intersectsSphere(sphere) {
    const l = Vector3.subtract(sphere.center, this.origin);
    const tca = l.dot(this.direction);
    const radiusSquared = sphere.radius * sphere.radius;
    const d2 = l.dot(l) - tca * tca;
    if (d2 > radiusSquared)
      return null;
    const thc = Math.sqrt(radiusSquared - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    const intersection = this.direction.clone();
    if (t0 < t1)
      intersection.multiplyScalar(t0);
    else
      intersection.multiplyScalar(t1);
    intersection.add(this.origin);
    return intersection;
  }
  intersectsBox(box) {
    let tmin = (box.min.x - this.origin.x) / this.direction.x;
    let tmax = (box.max.x - this.origin.x) / this.direction.x;
    if (tmin > tmax) {
      const temp = tmin;
      tmin = tmax;
      tmax = temp;
    }
    let tymin = (box.min.y - this.origin.y) / this.direction.y;
    let tymax = (box.max.y - this.origin.y) / this.direction.y;
    if (tymin > tymax) {
      const temp = tymin;
      tymin = tymax;
      tymax = temp;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin)
      tmin = tymin;
    if (tymax < tmax)
      tmax = tymax;
    let tzmin = (box.min.z - this.origin.z) / this.direction.z;
    let tzmax = (box.max.z - this.origin.z) / this.direction.z;
    if (tzmin > tzmax) {
      const temp = tzmin;
      tzmin = tzmax;
      tzmax = temp;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin)
      tmin = tzmin;
    if (tzmax < tmax)
      tmax = tzmax;
    const intersectionPoint = Vector3.multiplyScalar(this.direction, tmin);
    intersectionPoint.add(this.origin);
    return intersectionPoint;
  }
  intersectsOrientedBoundingBox(transform) {
    const localIntersection = this.createLocalRay(transform).intersectsBox(transform.boundingBox);
    if (localIntersection) {
      localIntersection.transform(transform.worldMatrix);
    }
    return localIntersection;
  }
  intersectsOrientedBoundingSphere(transform) {
    const localIntersection = this.createLocalRay(transform).intersectsSphere(transform.boundingSphere);
    if (localIntersection) {
      localIntersection.transform(transform.worldMatrix);
    }
    return localIntersection;
  }
  intersectsMesh(mesh) {
    const localRay = this.createLocalRay(mesh);
    if (!localRay.intersectsBox(mesh.boundingBox))
      return null;
    const vertices = mesh.getVertices();
    const indices = mesh.getIndices();
    const result = localRay.intersectsTriangles(vertices, indices);
    if (result)
      result.transform(mesh.worldMatrix);
    return result;
  }
  intersectsTriangles(vertices, indices) {
    let positions;
    if (typeof vertices[0] === "number") {
      positions = [];
      const vArray = vertices;
      for (let i = 0; i < vertices.length; i += 3) {
        positions.push(new Vector3(vArray[i], vArray[i + 1], vArray[i + 2]));
      }
    } else {
      positions = vertices;
    }
    const results = [];
    for (let i = 0; i < indices.length; i += 3) {
      const intersection = this.intersectsTriangle(positions[indices[i]], positions[indices[i + 1]], positions[indices[i + 2]]);
      if (intersection)
        results.push(intersection);
    }
    if (results.length == 0) {
      return null;
    } else if (results.length == 1) {
      return results[0];
    } else {
      let closestPoint = 0;
      let closestDistance = this.origin.distanceTo(results[0]);
      for (let i = 1; i < results.length; i++) {
        const distance = this.origin.distanceTo(results[i]);
        if (distance < closestDistance) {
          closestPoint = i;
          closestDistance = distance;
        }
      }
      return results[closestPoint];
    }
  }
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const EPSILON = 1e-7;
    const edge1 = Vector3.subtract(vertex1, vertex0);
    const edge2 = Vector3.subtract(vertex2, vertex0);
    const h = Vector3.cross(this.direction, edge2);
    const a = edge1.dot(h);
    if (a > -EPSILON && a < EPSILON) {
      return null;
    }
    const f = 1 / a;
    const s = Vector3.subtract(this.origin, vertex0);
    const u = f * s.dot(h);
    if (u < 0 || u > 1) {
      return null;
    }
    const q = Vector3.cross(s, edge1);
    const v = f * this.direction.dot(q);
    if (v < 0 || u + v > 1) {
      return null;
    }
    const t = f * edge2.dot(q);
    if (t > EPSILON) {
      const intersection = this.direction.clone();
      intersection.multiplyScalar(t);
      intersection.add(this.origin);
      return intersection;
    }
    return null;
  }
  createLocalRay(transform) {
    const localRay = new Ray(this.origin.clone(), this.direction.clone());
    const [worldPosition, worldRotation, worldScale] = transform.worldMatrix.decompose();
    localRay.origin.subtract(worldPosition);
    const inverseRotation = worldRotation.inverse();
    localRay.origin.rotate(inverseRotation);
    localRay.direction.rotate(inverseRotation);
    const scale = worldScale;
    const inverseScale = new Vector3();
    inverseScale.x = 1 / scale.x;
    inverseScale.y = 1 / scale.y;
    inverseScale.z = 1 / scale.z;
    localRay.origin.multiply(inverseScale);
    localRay.direction.multiply(inverseScale);
    localRay.direction.normalize();
    return localRay;
  }
};

// node_modules/gophergfx/src/interaction/TransformWidget.ts
var TransformWidget = class extends Transform3 {
  constructor(lineLength = 1, selectionWidth = 0.01, triggerDistance = 0.05) {
    super();
    this.currentAxis = -1;
    this.deviceCoords = new Vector2();
    this.selectionPoint = new Vector3();
    this.axes = new Axes3(lineLength);
    this.add(this.axes);
    this.thickAxes = [];
    this.thickAxes.push(new BoxMesh(lineLength, selectionWidth, selectionWidth));
    this.thickAxes.push(new BoxMesh(selectionWidth, lineLength, selectionWidth));
    this.thickAxes.push(new BoxMesh(selectionWidth, selectionWidth, lineLength));
    this.thickAxes[0].position.set(lineLength / 2, 0, 0);
    this.thickAxes[1].position.set(0, lineLength / 2, 0);
    this.thickAxes[2].position.set(0, 0, lineLength / 2);
    this.thickAxes[0].material = new UnlitMaterial();
    this.thickAxes[1].material = new UnlitMaterial();
    this.thickAxes[2].material = new UnlitMaterial();
    this.thickAxes[0].material.setColor(new Color(1, 0, 0));
    this.thickAxes[1].material.setColor(new Color(0, 1, 0));
    this.thickAxes[2].material.setColor(new Color(0, 0, 1));
    this.thickAxes[0].boundingBox.max.y = triggerDistance;
    this.thickAxes[0].boundingBox.max.z = triggerDistance;
    this.thickAxes[1].boundingBox.max.x = triggerDistance;
    this.thickAxes[1].boundingBox.max.z = triggerDistance;
    this.thickAxes[2].boundingBox.max.x = triggerDistance;
    this.thickAxes[2].boundingBox.max.y = triggerDistance;
    this.add(this.thickAxes[0]);
    this.add(this.thickAxes[1]);
    this.add(this.thickAxes[2]);
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
  }
  update(deltaTime) {
    const ray = new Ray();
    ray.setPickRay(this.deviceCoords, GfxApp.getInstance().camera);
    if (this.currentAxis == -1) {
      this.thickAxes[0].visible = false;
      this.thickAxes[1].visible = false;
      this.thickAxes[2].visible = false;
      if (ray.intersectsOrientedBoundingBox(this.thickAxes[0])) {
        this.thickAxes[0].visible = true;
      } else if (ray.intersectsOrientedBoundingBox(this.thickAxes[1])) {
        this.thickAxes[1].visible = true;
      } else if (ray.intersectsOrientedBoundingBox(this.thickAxes[2])) {
        this.thickAxes[2].visible = true;
      }
    } else if (this.currentAxis == 0) {
      const [worldPosition, worldRotation, worldScale] = GfxApp.getInstance().camera.worldMatrix.decompose();
      const projectedPosition = ray.intersectsPlane(new Plane(Vector3.ZERO, new Vector3(0, worldPosition.y, worldPosition.z)));
      if (projectedPosition) {
        this.translateX(projectedPosition.x - this.selectionPoint.x);
        this.selectionPoint = projectedPosition;
      }
    } else if (this.currentAxis == 1) {
      const [worldPosition, worldRotation, worldScale] = GfxApp.getInstance().camera.worldMatrix.decompose();
      const projectedPosition = ray.intersectsPlane(new Plane(Vector3.ZERO, new Vector3(worldPosition.x, 0, worldPosition.z)));
      if (projectedPosition) {
        this.translateY(projectedPosition.y - this.selectionPoint.y);
        this.selectionPoint = projectedPosition;
      }
    } else if (this.currentAxis == 2) {
      const [worldPosition, worldRotation, worldScale] = GfxApp.getInstance().camera.worldMatrix.decompose();
      const projectedPosition = ray.intersectsPlane(new Plane(Vector3.ZERO, new Vector3(worldPosition.x, worldPosition.y, 0)));
      if (projectedPosition) {
        this.translateZ(projectedPosition.z - this.selectionPoint.z);
        this.selectionPoint = projectedPosition;
      }
    }
  }
  onMouseDown(event) {
    this.deviceCoords = GfxApp.getInstance().getNormalizedDeviceCoordinates(event.x, event.y);
    const ray = new Ray();
    ray.setPickRay(this.deviceCoords, GfxApp.getInstance().camera);
    if (this.currentAxis == -1) {
      if (ray.intersectsOrientedBoundingBox(this.thickAxes[0])) {
        const [worldPosition, worldRotation, worldScale] = GfxApp.getInstance().camera.worldMatrix.decompose();
        const projectedPosition = ray.intersectsPlane(new Plane(Vector3.ZERO, new Vector3(0, worldPosition.y, worldPosition.z)));
        if (projectedPosition) {
          this.selectionPoint = projectedPosition;
          this.currentAxis = 0;
        }
        return;
      }
      if (ray.intersectsOrientedBoundingBox(this.thickAxes[1])) {
        const [worldPosition, worldRotation, worldScale] = GfxApp.getInstance().camera.worldMatrix.decompose();
        const projectedPosition = ray.intersectsPlane(new Plane(Vector3.ZERO, new Vector3(worldPosition.x, 0, worldPosition.z)));
        if (projectedPosition) {
          this.selectionPoint = projectedPosition;
          this.currentAxis = 1;
        }
        return;
      }
      if (ray.intersectsOrientedBoundingBox(this.thickAxes[2])) {
        const [worldPosition, worldRotation, worldScale] = GfxApp.getInstance().camera.worldMatrix.decompose();
        const projectedPosition = ray.intersectsPlane(new Plane(Vector3.ZERO, new Vector3(worldPosition.x, worldPosition.y, 0)));
        if (projectedPosition) {
          this.selectionPoint = projectedPosition;
          this.currentAxis = 2;
        }
        return;
      }
    }
  }
  onMouseUp(event) {
    this.currentAxis = -1;
  }
  onMouseMove(event) {
    this.deviceCoords = GfxApp.getInstance().getNormalizedDeviceCoordinates(event.x, event.y);
  }
  isSelected() {
    return this.currentAxis >= 0;
  }
};

// node_modules/gophergfx/src/lights/Light.ts
var LightType = /* @__PURE__ */ ((LightType2) => {
  LightType2[LightType2["POINT"] = 0] = "POINT";
  LightType2[LightType2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
  return LightType2;
})(LightType || {});
var Light = class extends Transform3 {
  constructor(type, ambientIntensity, diffuseIntensity, specularIntensity) {
    super();
    this.type = type;
    if (ambientIntensity instanceof Vector3)
      this.ambientIntensity = new Vector3(ambientIntensity.x, ambientIntensity.y, ambientIntensity.z);
    else
      this.ambientIntensity = new Vector3(ambientIntensity.r, ambientIntensity.g, ambientIntensity.b);
    if (diffuseIntensity instanceof Vector3)
      this.diffuseIntensity = new Vector3(diffuseIntensity.x, diffuseIntensity.y, diffuseIntensity.z);
    else
      this.diffuseIntensity = new Vector3(diffuseIntensity.r, diffuseIntensity.g, diffuseIntensity.b);
    if (specularIntensity instanceof Vector3)
      this.specularIntensity = new Vector3(specularIntensity.x, specularIntensity.y, specularIntensity.z);
    else
      this.specularIntensity = new Vector3(specularIntensity.r, specularIntensity.g, specularIntensity.b);
  }
  getType() {
    return this.type;
  }
  setLights(lightManager) {
    lightManager.addLight(this);
    super.setLights(lightManager);
  }
};

// node_modules/gophergfx/src/lights/AmbientLight.ts
var AmbientLight = class extends Light {
  constructor(intensity = new Vector3(0.5, 0.5, 0.5)) {
    super(0 /* POINT */, intensity, Vector3.ZERO, Vector3.ZERO);
  }
};

// node_modules/gophergfx/src/lights/DirectionalLight.ts
var DirectionalLight = class extends Light {
  constructor(intensity = new Vector3(0.5, 0.5, 0.5)) {
    super(1 /* DIRECTIONAL */, Vector3.ZERO, intensity, intensity);
  }
};

// node_modules/gophergfx/src/lights/PointLight.ts
var PointLight = class extends Light {
  constructor(intensity = new Vector3(0.5, 0.5, 0.5)) {
    super(0 /* POINT */, Vector3.ZERO, intensity, intensity);
  }
};

// node_modules/gophergfx/src/loaders/TextFileLoader.ts
var TextFile = class {
  constructor() {
    this.data = "";
  }
};
var TextFileLoader = class {
  static load(filename, callback = null) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    const textFile = new TextFile();
    fetch(filename).then((response) => {
      if (!response.ok)
        throw new Error();
      return response.blob();
    }).then((data) => {
      data.text().then((text) => {
        textFile.data = text;
        if (callback) {
          callback(textFile);
        }
        GfxApp.getInstance().assetManager.loadedAssets.push(filename);
      });
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to download file: " + filename);
    });
    return textFile;
  }
};

// node_modules/gophergfx/src/loaders/StringParser.ts
var StringParser = class {
  constructor(data) {
    this.tokens = [];
    this.line = 0;
    this.token = 0;
    const lines = data.split("\n");
    for (let i = 0; i < lines.length; i++) {
      this.tokens.push(lines[i].trim().split(/\s+/));
    }
    for (let i = 0; i < this.tokens.length; i++) {
      if (this.tokens[i].length == 1 && this.tokens[i][0] == "") {
        this.tokens.splice(i, 1);
        i--;
      }
    }
  }
  peek() {
    return this.tokens[this.line][this.token];
  }
  expect(token) {
    if (this.peek() == token) {
      this.readToken();
      return true;
    } else {
      return false;
    }
  }
  consumeLine() {
    this.line++;
    this.token = 0;
  }
  done() {
    return this.line >= this.tokens.length;
  }
  readToken() {
    const nextToken = this.tokens[this.line][this.token];
    this.token++;
    if (this.token >= this.tokens[this.line].length) {
      this.line++;
      this.token = 0;
    }
    return nextToken;
  }
  readNumber() {
    return Number(this.readToken());
  }
  readLine() {
    const nextLine = [];
    for (let i = this.token; i < this.tokens[this.line].length; i++) {
      nextLine.push(this.tokens[this.line][i]);
    }
    this.line++;
    this.token = 0;
    return nextLine;
  }
};

// node_modules/gophergfx/src/loaders/ObjLoader.ts
var ObjLoader = class {
  static load(filename, callback = null) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    const mesh = new Mesh();
    fetch(filename).then((response) => {
      if (!response.ok)
        throw new Error();
      return response.blob();
    }).then((data) => {
      data.text().then((text) => {
        ObjLoader.parse(text, mesh);
        if (callback) {
          callback(mesh);
        }
        GfxApp.getInstance().assetManager.loadedAssets.push(filename);
      });
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to download file: " + filename);
    });
    return mesh;
  }
  static parse(obj, mesh) {
    const parser = new StringParser(obj);
    const vertices = [];
    const colors = [];
    const normals = [];
    const indices = [];
    const uvs = [];
    while (!parser.done()) {
      const nextToken = parser.readToken();
      if (nextToken == "v")
        this.parseVertex(parser.readLine(), vertices, colors);
      else if (nextToken == "vn")
        this.parseNormal(parser.readLine(), normals);
      else if (nextToken == "vt")
        this.parseTextureCoordinate(parser.readLine(), uvs);
      else if (nextToken == "f")
        this.parseFace(parser.readLine(), indices);
      else
        parser.consumeLine();
    }
    mesh.setVertices(vertices);
    mesh.setColors(colors);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    if (colors.length == 0)
      mesh.createDefaultVertexColors();
    if (uvs.length / 2 == vertices.length / 3)
      mesh.setTextureCoordinates(uvs);
  }
  static parseVertex(line, vertices, colors) {
    vertices.push(Number(line[0]));
    vertices.push(Number(line[1]));
    vertices.push(Number(line[2]));
    if (line.length == 6) {
      colors.push(Number(line[3]));
      colors.push(Number(line[4]));
      colors.push(Number(line[5]));
      colors.push(1);
    }
  }
  static parseNormal(line, normals) {
    normals.push(Number(line[0]));
    normals.push(Number(line[1]));
    normals.push(Number(line[2]));
  }
  static parseTextureCoordinate(line, uvs) {
    uvs.push(Number(line[0]));
    uvs.push(Number(line[1]));
  }
  static parseFace(line, indices) {
    for (let i = 0; i < 3; i++) {
      const index = line[i].split("/");
      indices.push(Number(index[0]) - 1);
    }
  }
};

// node_modules/gophergfx/src/shaders/phong.vert
var phong_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\n\nout vec3 vertPosition;\nout vec3 vertNormal;\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the final vertex position and normal\n    vertPosition = (modelMatrix * vec4(position, 1)).xyz;\n    vertNormal = normalize((normalMatrix * vec4(normal, 0)).xyz);\n    vertColor = color;\n    uv = texCoord.xy; \n    gl_Position = projectionMatrix * viewMatrix * vec4(vertPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/phong.frag
var phong_default2 = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 8;\n\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec3 vertPosition;\nin vec3 vertNormal;\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n\n        // Normalize the interpolated normal vector\n        vec3 n = normalize(vertNormal);\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - vertPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(n, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - vertPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, n);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    fragColor = vertColor;\n    fragColor.rgb *= illumination;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/PhongMaterial.ts
var _PhongMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _PhongMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _PhongMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _PhongMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _PhongMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _PhongMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _PhongMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _PhongMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _PhongMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _PhongMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _PhongMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _PhongMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _PhongMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _PhongMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _PhongMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _PhongMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _PhongMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _PhongMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _PhongMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _PhongMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _PhongMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _PhongMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _PhongMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_PhongMaterial.shader.getProgram());
    const cameraPosition = new Vector3();
    cameraPosition.transform(camera.worldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, transform.worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, transform.worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.ambientColor.copy(color);
    this.diffuseColor.copy(color);
    this.specularColor.copy(color);
  }
};
var PhongMaterial = _PhongMaterial;
PhongMaterial.shader = new ShaderProgram(phong_default, phong_default2);

// node_modules/gophergfx/src/shaders/wireframe.vert
var wireframe_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() \n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n}";

// node_modules/gophergfx/src/shaders/wireframe.frag
var wireframe_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = color;\n}";

// node_modules/gophergfx/src/materials/WireframeMaterial.ts
var _WireframeMaterial = class extends Material3 {
  constructor() {
    super();
    this.color = new Color(1, 1, 1, 1);
    _WireframeMaterial.shader.initialize(this.gl);
    this.positionAttribute = _WireframeMaterial.shader.getAttribute(this.gl, "position");
    this.modelViewUniform = _WireframeMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = _WireframeMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.colorUniform = _WireframeMaterial.shader.getUniform(this.gl, "color");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_WireframeMaterial.shader.getProgram());
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(transform.worldMatrix, camera.viewMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (!_WireframeMaterial.wireframeBuffers.get(mesh)) {
      this.updateWireframeBuffer(mesh);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, _WireframeMaterial.wireframeBuffers.get(mesh));
    this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);
  }
  setColor(color) {
    this.color.copy(color);
  }
  updateWireframeBuffer(mesh) {
    let wireframeBuffer;
    wireframeBuffer = _WireframeMaterial.wireframeBuffers.get(mesh);
    if (!wireframeBuffer) {
      wireframeBuffer = this.gl.createBuffer();
      if (wireframeBuffer)
        _WireframeMaterial.wireframeBuffers.set(mesh, wireframeBuffer);
    }
    const indexArray = new Uint16Array(mesh.triangleCount * 3);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);
    const indices = [...indexArray];
    const wireframeIndices = [];
    for (let i = 0; i < mesh.triangleCount; i++) {
      wireframeIndices.push(indices[i * 3]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3]);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);
  }
};
var WireframeMaterial = _WireframeMaterial;
WireframeMaterial.shader = new ShaderProgram(wireframe_default, wireframe_default2);
WireframeMaterial.wireframeBuffers = /* @__PURE__ */ new Map();

// node_modules/gophergfx/src/materials/BoundingVolumeMaterial.ts
var BoundingVolumeMode = /* @__PURE__ */ ((BoundingVolumeMode2) => {
  BoundingVolumeMode2[BoundingVolumeMode2["ORIENTED_BOUNDING_BOX"] = 0] = "ORIENTED_BOUNDING_BOX";
  BoundingVolumeMode2[BoundingVolumeMode2["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  BoundingVolumeMode2[BoundingVolumeMode2["BOUNDING_SPHERE"] = 2] = "BOUNDING_SPHERE";
  return BoundingVolumeMode2;
})(BoundingVolumeMode || {});
var BoundingVolumeMaterial = class extends Material3 {
  constructor(mode = 0 /* ORIENTED_BOUNDING_BOX */, color = new Color(1, 1, 1, 1)) {
    super();
    this.mode = mode;
    this.color = Color.copy(color);
    this.sphere = new SphereMesh(1, 1);
    const boundingBox = new BoundingBox3();
    boundingBox.max.set(0.5, 0.5, 0.5);
    boundingBox.min.set(-0.5, -0.5, -0.5);
    this.box = new Line3();
    this.box.createFromBox(boundingBox);
    this.wireframeMaterial = new WireframeMaterial();
    this.wireframeMaterial.color = color;
    this.sphere.material = this.wireframeMaterial;
    this.lineMaterial = new LineMaterial();
    this.lineMaterial.color = color;
    this.box.material = this.lineMaterial;
  }
  draw(mesh, transform, camera, lightManager) {
    if (this.mode == 0 /* ORIENTED_BOUNDING_BOX */) {
      this.box.position.copy(mesh.boundingBox.min);
      this.box.position.add(mesh.boundingBox.max);
      this.box.position.multiplyScalar(0.5);
      this.box.scale.set(
        mesh.boundingBox.max.x - mesh.boundingBox.min.x,
        mesh.boundingBox.max.y - mesh.boundingBox.min.y,
        mesh.boundingBox.max.z - mesh.boundingBox.min.z
      );
      this.box.parent = mesh;
      this.box.traverseSceneGraph();
      this.box.draw(mesh, camera, lightManager);
    } else if (this.mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */) {
      const abb = new BoundingBox3();
      abb.copy(mesh.boundingBox);
      const [worldPosition, worldRotation, worldScale] = mesh.worldMatrix.decompose();
      abb.transform(worldPosition, worldRotation, worldScale);
      this.box.position.copy(abb.min);
      this.box.position.add(abb.max);
      this.box.position.multiplyScalar(0.5);
      this.box.scale.set(
        abb.max.x - abb.min.x,
        abb.max.y - abb.min.y,
        abb.max.z - abb.min.z
      );
      this.box.matrix.compose(this.box.position, this.box.rotation, this.box.scale);
      this.box.worldMatrix.copy(this.box.matrix);
      this.box.draw(mesh, camera, lightManager);
    } else if (this.mode == 2 /* BOUNDING_SPHERE */) {
      const [worldPosition, worldRotation, worldScale] = mesh.worldMatrix.decompose();
      this.sphere.position.copy(worldPosition);
      this.sphere.position.add(mesh.boundingSphere.center);
      this.sphere.scale.set(mesh.boundingSphere.radius, mesh.boundingSphere.radius, mesh.boundingSphere.radius);
      this.sphere.matrix.compose(this.sphere.position, this.sphere.rotation, this.sphere.scale);
      this.sphere.worldMatrix.copy(this.sphere.matrix);
      this.sphere.draw(mesh, camera, lightManager);
    }
  }
  setColor(color) {
    this.color.copy(color);
  }
};

// node_modules/gophergfx/src/shaders/morph.vert
var morph_default = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 8;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nuniform float morphAlpha;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\nin vec3 morphTargetPosition;\nin vec3 morphTargetNormal;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the final vertex position and normal\n    vec3 worldPosition, worldNormal;\n    if(morphAlpha > 0.0f)\n    {\n        worldPosition = mix(position, morphTargetPosition, morphAlpha);\n        worldPosition = (modelMatrix * vec4(worldPosition, 1)).xyz;\n        worldNormal = mix(normal, morphTargetNormal, morphAlpha);\n        worldNormal = normalize((normalMatrix * vec4(worldNormal, 0)).xyz);\n\n    }\n    else\n    {\n        worldPosition = (modelMatrix * vec4(position, 1)).xyz;\n        worldNormal = normalize((normalMatrix * vec4(normal, 0)).xyz);\n    }\n\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - worldPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(worldNormal, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - worldPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, worldNormal);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    vertColor = color;\n    vertColor.rgb *= illumination;\n\n    uv = texCoord.xy; \n\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/morph.frag
var morph_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/MorphMaterial.ts
var _MorphMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _MorphMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _MorphMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _MorphMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _MorphMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _MorphMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _MorphMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _MorphMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _MorphMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _MorphMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _MorphMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _MorphMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _MorphMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _MorphMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _MorphMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _MorphMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _MorphMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _MorphMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _MorphMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _MorphMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _MorphMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _MorphMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _MorphMaterial.shader.getAttribute(this.gl, "texCoord");
    this.morphAlpha = 0;
    this.morphAlphaUniform = _MorphMaterial.shader.getUniform(this.gl, "morphAlpha");
    this.morphTargetPositionAttribute = _MorphMaterial.shader.getAttribute(this.gl, "morphTargetPosition");
    this.morphTargetNormalAttribute = _MorphMaterial.shader.getAttribute(this.gl, "morphTargetNormal");
    this.wireframe = false;
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_MorphMaterial.shader.getProgram());
    const cameraPosition = new Vector3();
    cameraPosition.transform(camera.worldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, transform.worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, transform.worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.uniform1f(this.morphAlphaUniform, this.morphAlpha);
    if (this.morphAlpha > 0) {
      this.gl.enableVertexAttribArray(this.morphTargetPositionAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.morphTargetPositionBuffer);
      this.gl.vertexAttribPointer(this.morphTargetPositionAttribute, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.enableVertexAttribArray(this.morphTargetNormalAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.morphTargetNormalBuffer);
      this.gl.vertexAttribPointer(this.morphTargetNormalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.disableVertexAttribArray(this.morphTargetPositionAttribute);
      this.gl.disableVertexAttribArray(this.morphTargetNormalAttribute);
    }
    if (this.wireframe) {
      this.gl.uniform1i(this.useTextureUniform, 0);
      this.gl.disableVertexAttribArray(this.texCoordAttribute);
      if (!_MorphMaterial.wireframeBuffers.get(mesh)) {
        this.updateWireframeBuffer(mesh);
      }
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, _MorphMaterial.wireframeBuffers.get(mesh));
      this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);
    } else {
      if (this.texture) {
        this.gl.uniform1i(this.useTextureUniform, 1);
        this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
        this.gl.uniform1i(this.textureUniform, this.texture.id);
        this.gl.enableVertexAttribArray(this.texCoordAttribute);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
        this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
      } else {
        this.gl.uniform1i(this.useTextureUniform, 0);
        this.gl.disableVertexAttribArray(this.texCoordAttribute);
      }
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
      this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
    }
  }
  setColor(color) {
    this.ambientColor.copy(color);
    this.diffuseColor.copy(color);
    this.specularColor.copy(color);
  }
  updateWireframeBuffer(mesh) {
    let wireframeBuffer;
    wireframeBuffer = _MorphMaterial.wireframeBuffers.get(mesh);
    if (!wireframeBuffer) {
      wireframeBuffer = this.gl.createBuffer();
      if (wireframeBuffer)
        _MorphMaterial.wireframeBuffers.set(mesh, wireframeBuffer);
    }
    const indexArray = new Uint16Array(mesh.triangleCount * 3);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.getBufferSubData(this.gl.ELEMENT_ARRAY_BUFFER, 0, indexArray);
    const indices = [...indexArray];
    const wireframeIndices = [];
    for (let i = 0; i < mesh.triangleCount; i++) {
      wireframeIndices.push(indices[i * 3]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3]);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);
  }
};
var MorphMaterial = _MorphMaterial;
MorphMaterial.shader = new ShaderProgram(morph_default, morph_default2);
MorphMaterial.wireframeBuffers = /* @__PURE__ */ new Map();

// node_modules/gophergfx/src/materials/Texture.ts
var _Texture = class {
  constructor(url = null) {
    this.gl = GfxApp.getInstance().renderer.gl;
    this.texture = this.gl.createTexture();
    this.id = _Texture.numTextures;
    _Texture.numTextures++;
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      1,
      1,
      0,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      new Uint8Array([255, 0, 255, 255])
    );
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    if (url) {
      this.load(url);
    }
  }
  load(url) {
    GfxApp.getInstance().assetManager.requestedAssets.push(url);
    const image = new Image();
    image.addEventListener("load", (event) => {
      this.imageLoaded(image, url);
    }, false);
    image.addEventListener("error", (event) => {
      this.imageNotFound(url);
    }, false);
    image.src = url;
  }
  imageLoaded(image, url) {
    GfxApp.getInstance().assetManager.loadedAssets.push(url);
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
    this.gl.generateMipmap(this.gl.TEXTURE_2D);
  }
  imageNotFound(url) {
    GfxApp.getInstance().assetManager.errorAssets.push(url);
  }
  setMinFilter(linear, mipmap) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    if (linear) {
      if (mipmap)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_LINEAR);
      else
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    } else {
      if (mipmap)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST_MIPMAP_NEAREST);
      else
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    }
  }
  setMagFilter(linear) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    if (linear)
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
    else
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
  }
  setWrapping(repeat) {
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    if (repeat) {
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
    } else {
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    }
  }
};
var Texture = _Texture;
Texture.numTextures = 0;

// node_modules/gophergfx/src/materials/Text.ts
var Text = class extends Texture {
  constructor(text, width, height, font = "24px monospace", fillStyle = "black", backgroundStyle = "", strokeStyle = "", strokeWidth = 1, align = "center", baseline = "middle") {
    super();
    this.text = text;
    this.width = width;
    this.height = height;
    this.font = font;
    this.fillStyle = fillStyle;
    this.backgroundStyle = backgroundStyle;
    this.strokeStyle = strokeStyle;
    this.strokeWidth = strokeWidth;
    this.align = align;
    this.baseline = baseline;
    this.textCanvas = document.createElement("canvas").getContext("2d");
    this.updateTextureImage();
  }
  updateTextureImage() {
    if (this.textCanvas) {
      this.textCanvas.canvas.width = this.width;
      this.textCanvas.canvas.height = this.height;
      this.textCanvas.font = this.font;
      this.textCanvas.textAlign = this.align;
      this.textCanvas.textBaseline = this.baseline;
      this.textCanvas.clearRect(0, 0, this.width, this.height);
      if (this.backgroundStyle != "") {
        this.textCanvas.fillStyle = this.backgroundStyle;
        this.textCanvas.fillRect(0, 0, this.width, this.height);
      }
      if (this.fillStyle != "") {
        this.textCanvas.fillStyle = this.fillStyle;
        this.textCanvas.fillText(this.text, this.width / 2, this.height / 2);
      }
      if (this.strokeStyle != "" && this.strokeWidth > 0) {
        this.textCanvas.strokeStyle = this.strokeStyle;
        this.textCanvas.lineWidth = this.strokeWidth;
        this.textCanvas.strokeText(this.text, this.width / 2, this.height / 2);
      }
      this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.textCanvas.canvas);
      this.gl.generateMipmap(this.gl.TEXTURE_2D);
    }
  }
};

// node_modules/gophergfx/src/math/LinearPath3.ts
var LinearPath3 = class {
  constructor() {
    this.controlPoints = [];
  }
  getPoint(segment, t) {
    if (segment < this.controlPoints.length - 1) {
      return Vector3.lerp(this.controlPoints[segment], this.controlPoints[segment + 1], MathUtils.clamp(t, 0, 1));
    } else {
      return null;
    }
  }
};

// node_modules/gophergfx/src/math/CurvePath3.ts
var CurvePath3 = class {
  constructor(alpha = 0.5, tension = 0) {
    this.controlPoints = [];
    this.alpha = alpha;
    this.tension = tension;
  }
  getPoint(segment, t) {
    if (segment == 0) {
      const v = Vector3.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const firstPoint = Vector3.subtract(this.controlPoints[segment], v);
      return this.computePoint(
        firstPoint,
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    }
    if (segment < this.controlPoints.length - 2) {
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 2) {
      const v = Vector3.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const lastPoint = Vector3.add(this.controlPoints[segment + 1], v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 1) {
      const v = Vector3.subtract(this.controlPoints[segment], this.controlPoints[segment - 1]);
      const secondToLastPoint = Vector3.add(this.controlPoints[segment], v);
      const lastPoint = Vector3.add(secondToLastPoint, v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        secondToLastPoint,
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else {
      return null;
    }
  }
  computePoint(p0, p1, p2, p3, t) {
    const t01 = Math.pow(p0.distanceTo(p1), this.alpha);
    const t12 = Math.pow(p1.distanceTo(p2), this.alpha);
    const t23 = Math.pow(p2.distanceTo(p3), this.alpha);
    const p1p0 = Vector3.subtract(p1, p0);
    const p1p2 = Vector3.subtract(p1, p2);
    const p2p0 = Vector3.subtract(p2, p0);
    const p2p1 = Vector3.subtract(p2, p1);
    const p3p1 = Vector3.subtract(p3, p1);
    const p3p2 = Vector3.subtract(p3, p2);
    const m1 = Vector3.multiplyScalar(p1p0, 1 / t01);
    m1.subtract(Vector3.multiplyScalar(p2p0, 1 / (t01 + t12)));
    m1.multiplyScalar(t12);
    m1.add(p2p1);
    m1.multiplyScalar(1 - this.tension);
    const m2 = Vector3.multiplyScalar(p3p2, 1 / t23);
    m2.subtract(Vector3.multiplyScalar(p3p1, 1 / (t12 + t23)));
    m2.multiplyScalar(t12);
    m2.add(p2p1);
    m2.multiplyScalar(1 - this.tension);
    const a = Vector3.multiplyScalar(p1p2, 2);
    a.add(m1);
    a.add(m2);
    const b = Vector3.multiplyScalar(p1p2, -3);
    b.subtract(m1);
    b.subtract(m1);
    b.subtract(m2);
    const c = m1;
    const d = p1;
    const result = Vector3.multiplyScalar(a, t * t * t);
    result.add(Vector3.multiplyScalar(b, t * t));
    result.add(Vector3.multiplyScalar(c, t));
    result.add(d);
    return result;
  }
};

// node_modules/gophergfx/src/math/LinearPath2.ts
var LinearPath2 = class {
  constructor() {
    this.controlPoints = [];
  }
  getPoint(segment, t) {
    if (segment < this.controlPoints.length - 1) {
      return Vector2.lerp(this.controlPoints[segment], this.controlPoints[segment + 1], MathUtils.clamp(t, 0, 1));
    } else {
      return null;
    }
  }
};

// node_modules/gophergfx/src/math/CurvePath2.ts
var CurvePath2 = class {
  constructor(alpha = 0.5, tension = 0) {
    this.controlPoints = [];
    this.alpha = alpha;
    this.tension = tension;
  }
  getPoint(segment, t) {
    if (segment == 0) {
      const v = Vector2.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const firstPoint = Vector2.subtract(this.controlPoints[segment], v);
      return this.computePoint(
        firstPoint,
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    }
    if (segment < this.controlPoints.length - 2) {
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        this.controlPoints[segment + 2],
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 2) {
      const v = Vector2.subtract(this.controlPoints[segment + 1], this.controlPoints[segment]);
      const lastPoint = Vector2.add(this.controlPoints[segment + 1], v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        this.controlPoints[segment + 1],
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else if (segment == this.controlPoints.length - 1) {
      const v = Vector2.subtract(this.controlPoints[segment], this.controlPoints[segment - 1]);
      const secondToLastPoint = Vector2.add(this.controlPoints[segment], v);
      const lastPoint = Vector2.add(secondToLastPoint, v);
      return this.computePoint(
        this.controlPoints[segment - 1],
        this.controlPoints[segment],
        secondToLastPoint,
        lastPoint,
        MathUtils.clamp(t, 0, 1)
      );
    } else {
      return null;
    }
  }
  computePoint(p0, p1, p2, p3, t) {
    const t01 = Math.pow(p0.distanceTo(p1), this.alpha);
    const t12 = Math.pow(p1.distanceTo(p2), this.alpha);
    const t23 = Math.pow(p2.distanceTo(p3), this.alpha);
    const p1p0 = Vector2.subtract(p1, p0);
    const p1p2 = Vector2.subtract(p1, p2);
    const p2p0 = Vector2.subtract(p2, p0);
    const p2p1 = Vector2.subtract(p2, p1);
    const p3p1 = Vector2.subtract(p3, p1);
    const p3p2 = Vector2.subtract(p3, p2);
    const m1 = Vector2.multiplyScalar(p1p0, 1 / t01);
    m1.subtract(Vector2.multiplyScalar(p2p0, 1 / (t01 + t12)));
    m1.multiplyScalar(t12);
    m1.add(p2p1);
    m1.multiplyScalar(1 - this.tension);
    const m2 = Vector2.multiplyScalar(p3p2, 1 / t23);
    m2.subtract(Vector2.multiplyScalar(p3p1, 1 / (t12 + t23)));
    m2.multiplyScalar(t12);
    m2.add(p2p1);
    m2.multiplyScalar(1 - this.tension);
    const a = Vector2.multiplyScalar(p1p2, 2);
    a.add(m1);
    a.add(m2);
    const b = Vector2.multiplyScalar(p1p2, -3);
    b.subtract(m1);
    b.subtract(m1);
    b.subtract(m2);
    const c = m1;
    const d = p1;
    const result = Vector2.multiplyScalar(a, t * t * t);
    result.add(Vector2.multiplyScalar(b, t * t));
    result.add(Vector2.multiplyScalar(c, t));
    result.add(d);
    return result;
  }
};
export {
  AmbientLight,
  AssetManager,
  Axes2,
  Axes3,
  BoundingBox2,
  BoundingBox3,
  BoundingCircle,
  BoundingSphere,
  BoundingVolumeMaterial,
  BoundingVolumeMode,
  BoxMesh,
  Camera,
  Circle,
  Color,
  ConeMesh,
  CurvePath2,
  CurvePath3,
  CylinderMesh,
  DirectionalLight,
  FirstPersonControls,
  GfxApp,
  GouraudMaterial,
  IntersectionMode2,
  IntersectionMode3,
  Light,
  LightManager,
  LightType,
  Line2,
  Line3,
  LineMaterial,
  LineMode2,
  LineMode3,
  LinearPath2,
  LinearPath3,
  Material2,
  Material3,
  MathUtils,
  Matrix4,
  Mesh,
  MeshInstance,
  MorphMaterial,
  ObjLoader,
  OrbitControls,
  Particles2,
  PhongMaterial,
  Plane,
  PlaneMesh,
  PointLight,
  Quaternion,
  Ray,
  Rectangle,
  Renderer,
  Scene,
  ShaderProgram,
  Shape,
  ShapeInstance,
  Side,
  SphereMesh,
  StringParser,
  Text,
  TextFile,
  TextFileLoader,
  Texture,
  Transform2,
  Transform3,
  TransformWidget,
  UnlitMaterial,
  Vector2,
  Vector3,
  Viewport,
  WireframeMaterial
};
//# sourceMappingURL=gophergfx.js.map
